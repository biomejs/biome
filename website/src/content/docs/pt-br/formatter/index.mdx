---
title: Formatador
description: Como usar o formatador do Biome.
---

import PackageManagerBiomeCommand from "@src/components/PackageManagerBiomeCommand.astro";

O Biome √© uma ferramenta de formata√ß√£o com convic√ß√µes fortes que tem o objetivo de acabar com os cont√≠nuos debates sobre estilo de c√≥digo.
Ele segue uma [filosofia semelhante √† do Prettier](https://prettier.io/docs/en/option-philosophy.html) (link em ingl√™s),
dando suporte a apenas algumas op√ß√µes para evitar que debates sobre estilos se tornem debates sobre as op√ß√µes de configura√ß√£o do Biome.
Ele deliberadamente [resiste ao af√£ de adicionar novas op√ß√µes](https://github.com/prettier/prettier/issues/40) para evitar [discuss√µes triviais](https://pt.wikipedia.org/wiki/Lei_da_trivialidade) nas equipes, para que elas possam se concentrar no que realmente importa.

## Op√ß√µes

As op√ß√µes, agn√≥sticas da linguagem, suportadas pelo Biome s√£o:

- estilo de indenta√ß√£o (padr√£o: `tab`): Use espa√ßos ou tabula√ß√µes para a indenta√ß√£o
- largura da tabula√ß√£o (padr√£o: `2`): O n√∫mero de espa√ßos por n√≠vel de indenta√ß√£o
- comprimento de linha (padr√£o: `80`): N√∫mero de colunas m√°ximo a partir do qual Biome quebra a linha

Outras op√ß√µes de formata√ß√£o tamb√©m est√£o dispon√≠veis para linguagens espec√≠ficas. Consulte as op√ß√µes de [configura√ß√£o](/reference/configuration) para obter detalhes.

## Use o formatador com a linha de comando

Por padr√£o, o formatador **verifica** o c√≥digo e emite diagn√≥sticos se houver altera√ß√µes na formata√ß√£o:

<PackageManagerBiomeCommand command="format ./src" />

Se voc√™ quiser **aplicar** a nova formata√ß√£o, passe a op√ß√£o `--write`:

<PackageManagerBiomeCommand command="format --write ./src" />

Use a flag `--help` para saber quais s√£o as op√ß√µes dispon√≠veis:

<PackageManagerBiomeCommand command="format --help" />

Ou confira a [se√ß√£o de refer√™ncia dos comandos de linha](/reference/cli#biomeformat).

## Configura√ß√£o

Voc√™ pode querer [configurar o Biome](/reference/configuration/#formatter) usando `biome.json`.
Os seguintes padr√µes s√£o aplicados:

```json title="biome.json"
{
  "formatter": {
    "enabled": true,
    "formatWithErrors": false,
    "indentStyle": "tab",
    "indentWidth": 2,
    "lineWidth": 80,
    "ignore": []
  }
}
```

## Ignorando C√≥digo

H√° ocasi√µes em que o c√≥digo formatado n√£o √© ideal.

Para esses casos, voc√™ pode usar um coment√°rio de supress√£o de formata√ß√£o:

```js title="example.js"
// biome-ignore format: <explica√ß√£o>
```

Exemplo:

```js title="example.js"
const expr =
  // biome-ignore format: este array n√£o deve ser formatado
  [
    (2 * n) / (r - l),
    0,
    (r + l) / (r - l),
    0,
    0,
    (2 * n) / (t - b),
    (t + b) / (t - b),
    0,
    0,
    0,
    -(f + n) / (f - n),
    -(2 * f * n) / (f - n),
    0,
    0,
    -1,
    0,
  ];
```

## Diferen√ßas com o Prettier

H√° algumas diverg√™ncias com o Prettier.

### O Prettier n√£o remove aspas de algumas propriedades de objeto que seriam identificadores JavaScript v√°lidos.

O Prettier e o Biome removem as aspas de propriedades de objetos e classes que s√£o identificadores JavaScript v√°lidos.
O Prettier [faz isso apenas para identificadores v√°lidos pelo ES5](https://github.com/prettier/prettier/blob/a5d502513e5de4819a41fd90b9be7247146effc7/src/language-js/utils/index.js#L646).

Esta √© um restri√ß√£o considerada legado em um ecossistema no qual o ES2015 j√° est√° bastante difundido.
Portanto, decidimos divergir aqui, retirando as aspas de todos os identificadores JavaScript v√°lidos a partir do ES2015.

Uma alternativa poss√≠vel seria introduzir uma configura√ß√£o para a vers√£o do ECMAScript usado pelo projeto.
Assim, poder√≠amos ajustar o comportamento de remo√ß√£o de aspas com base na vers√£o.
Definir a vers√£o do ECMAScript como `ES5` emularia o comportamento do Prettier.

```js title="example.js"
const obj = {
 'a': true,
 b: true,
 "êäß": true,
}
```

Diff

```js title="exmaple.js" del={4} ins={5}
const obj = {
  a: true,
  b: true,
  "êäß": true,
  êäß: true,
};
```


### Prettier tem um comportamento inconsistente com atribui√ß√£o em chaves computadas.

O Prettier e o Biome colocam algumas express√µes de atribui√ß√£o entre par√™nteses, especialmente em condicionais.
Isso permite que o Biome identifique uma express√£o que deveria ser uma compara√ß√£o.

O Prettier tem um comportamento inconsistente porque adiciona par√™nteses para uma atribui√ß√£o em uma chave computada de uma propriedade de objeto e n√£o o faz para uma chave computada de uma propriedade de classe, conforme demonstrado no exemplo a seguir:

Input

```js title="example.js"
a = {
  [x = 0]: 1,
}

class C {
  [x = 0] = 1
}
```

Diff

```js title="example.js" del={2} ins={3}
a = {
  [(x = 0)]: 1,
  [x = 0]: 1,
};

class C {
  [x = 0] = 1;
}
```

[Link do playground](https://biomejs.dev/playground?enabledLinting=false&code=YQAgAD0AIAB7AAoAIAAgAFsAeAAgAD0AIAAwAF0AOgAgADEALAAKAH0ACgAKAGMAbABhAHMAcwAgAEMAIAB7AAoAIAAgACAAIABbAHgAIAA9ACAAMABdACAAPQAgADEACgB9AAoA)

Para sermos consistentes, decidimos divergir e omitir os par√™nteses.
De forma alternativa, poder√≠amos incluir par√™nteses ao redor de qualquer atribui√ß√£o em uma chave computada de um objeto ou de uma classe.


### O Prettier adiciona uma v√≠rgula final aos par√¢metros de tipo das arrow functions, mesmo quando n√£o √© necess√°rio.

Em alguns casos espec√≠ficos, uma lista de par√¢metros de tipo de uma arrow fuction requer uma v√≠rgula final para distingui-la de um elemento JSX.
Quando um tipo padr√£o √© fornecido, essa v√≠rgula final n√£o √© necess√°ria.
Aqui, divergimos do Prettier porque acreditamos respeitar melhor a inten√ß√£o original do pr√≥prio Prettier, que era adicionar uma v√≠rgula final somente quando necess√°rio.

Input

```tsx title="example.tsx"
<T = unknown>() => {};
```

Diff

```tsx title="example.tsx" del={1} ins={2}
<T = unknown,>() => {};
<T = unknown>() => {};
```


### Prettier formata sintax inv√°lida

A an√°lise do Prettier, com base no Babel, para JavaScript e TypeScript √© flex√≠vel at√© demais e [permite que muitos erros](https://github.com/prettier/prettier/blob/e4a74c05f4502dd4ec70495c3130ff08ab088e05/src/language-js/parse/babel.js#L177-L218) sejam ignorados. 
O analisador sint√°tico do Biome √© propositalmente mais rigoroso do que o analisador do Prettier.
Ele identifica corretamente os seguintes erros de sintaxe:

- Uma fun√ß√£o n√£o pode ter modificadores duplicados
- Ordem inv√°lida dos modificadores de propriedades
- N√£o √© permitido que as declara√ß√µes de fun√ß√£o tenham corpo
- Classes n√£o abstratas n√£o podem ter propriedades abstratas
- Uma cadeia opcional n√£o pode ser atribu√≠da
- O modificador `const` n√£o pode ser definido em um par√¢metro de tipo de uma interface.
- retorno no n√≠vel mais alto
- etc.

No Prettier, esses erros n√£o s√£o considerados erros de an√°lise sint√°tica, e a AST (√°rvore sint√°tica abstrata) ainda √© constru√≠da "corretamente" com os n√≥s apropriados.
Ao formatar, o Prettier trata esses n√≥s como normais e os formata de acordo.

No Biome, os erros de an√°lise resultam em n√≥s do tipo `Bogus` (defeituosos), que podem conter um n√∫mero qualquer de n√≥s v√°lidos, n√≥s inv√°lidos e/ou caracteres crus.
Ao formatar, o Biome trata os n√≥s defeituosos como texto simples, copiando-os literalmente no c√≥digo resultante sem nenhuma formata√ß√£o, pois a tentativa de format√°-los poderia ser incorreta e causar altera√ß√µes sem√¢nticas.

Para propriedades de classe, a estrat√©gia de an√°lise atual do Prettier tamb√©m usa campos booleanos para modificadores, o que significa que apenas um de cada tipo de modificador pode estar presente (os modificadores de acessibilidade s√£o armazenados como uma √∫nica string).
Ao renderizar, o Prettier examina a lista de booleanos e decide quais modificadores devem ser copiados novamente. Em vez disso, o Biome mant√©m uma lista de modificadores, o que significa que as duplicatas s√£o mantidas e podem ser analisadas (da√≠ as mensagens de erro de an√°lise sobre modificadores duplicados e ordena√ß√£o).
Ao imprimir os n√≥s defeituosos, essa lista √© mantida intacta, e a c√≥pia do texto n√£o formatado faz com que esses modificadores continuem existindo.

O Biome pode resolver isso de v√°rias maneiras.
Uma possibilidade √© tentar interpretar os n√≥s defeituosos durante a formata√ß√£o e construir n√≥s v√°lidos a partir deles.
Se um n√≥ v√°lido puder ser criado, ele apenas formataria esse n√≥ normalmente; caso contr√°rio, renderizaria o texto defeituoso literalmente, como faz atualmente.
No entanto, isso pode ser confuso e introduz uma l√≥gica de an√°lise sint√°tica no formatador que n√£o agrega valor.

Outra op√ß√£o √© introduzir alguma forma de "n√≥ defeituoso sintaticamente v√°lido" no analisador, que aceita esses tipos de erros puramente sem√¢nticos (modificadores duplicados, propriedades abstratas em classes n√£o abstratas).

Ele continuaria a criar os n√≥s normalmente (efetivamente correspondendo ao comportamento do Prettier), mas os armazenaria dentro de um novo tipo de n√≥ defeituoso, incluindo os diagn√≥sticos junto.
Durante a formata√ß√£o, esses n√≥s defeituosos em espec√≠fico tentariam formatar o n√≥ interno, voltando atr√°s se houvesse um erro (o utilit√°rio `format_or_verbatim` existente j√° faria isso).
Isso mant√©m a l√≥gica de an√°lise e formata√ß√£o separada uma da outra, mas introduz mais complexidade ao analisador, permitindo que estados inv√°lidos sejam considerados semi-v√°lidos.

#### Modificadores duplicados em propriedades de classe

Input

```ts title="example.ts"
// V√°rios modificadores de acessibilidade
class Foo {
  private public a  = 1;
}

// Declarando fun√ß√£o com corpo
declare function foo ( ) {  }

// Uso inv√°lido de `abstract`
class Bar {
  abstract  foo  ;
}

// Duplica√ß√£o de `readonly`
class Read {
  readonly readonly   x: number;
}
```

Diff

```ts title="example.ts" del={3, 8, 13, 19} ins={4, 9, 14, 20}
// V√°rios modificadores de acessibilidade
class Foo {
  private a = 1;
  private public a  = 1;
}

// Declarando fun√ß√£o com corpo
declare function foo() {};
declare function foo ( ) {  }

// Uso inv√°lido de `abstract`
class Bar {
  abstract foo;
  abstract  foo  ;
}

// Duplica√ß√£o de `readonly`
class Read {
  readonly x: number;
  readonly readonly   x: number;
}
```


#### Atribui√ß√£o a uma cadeia opcional

Input

```js title="example.js"
(a?.b) = c;
```

Diff

```js title="example.js" del={1} ins={2}
a?.b = c;
(a?.b) = c;
```

#### Modificador incorreto para os par√¢metros de tipo de uma interface

Input

```ts title="example.js"
interface L<in const T> {}
```

Diff

```ts title="example.js" del={1} ins={2}
interface L<const in T> {}
interface L<in const T> {}
```

#### Retorno de n√≠vel superior

```js title="example.js"
return umaStringMuitoLongaA && umaStringMuitoLongaB && umaStringMuitoLongaC && umaStringMuitoLongaD
```

```js title="example.js" del={1, 2, 3, 4, 5, 6} ins={7}
return (
  umaStringMuitoLongaA &&
  umaStringMuitoLongaB &&
  umaStringMuitoLongaC &&
  umaStringMuitoLongaD
);
return umaStringMuitoLongaA && umaStringMuitoLongaB && umaStringMuitoLongaC && umaStringMuitoLongaD
```

#### Autoincremento e autodecremento err√¥neos

Input

```js title="example.js"
(1)++;
```

```js title="example.js" del{1} add={2}
1++;
(1)++;
```

#### Uso do modificador `abstract` em classes n√£o abstratas

Input

```ts title="example.js"
class C {
  abstract f() : number;
}
```

Diff


```ts title="example.js" del{2} add={3}
class C {
  abstract f(): number;
  abstract f() : number;
}
```

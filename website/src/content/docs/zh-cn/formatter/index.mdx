---
title: 格式化器
description: 如何使用 Biome 格式化器。
---

import PackageManagerBiomeCommand from "@src/components/PackageManagerBiomeCommand.astro";

Biome 是一个有自己观点的格式化器，其目标是停止所有关于样式的争论。
它遵循类似于 [Prettier 的哲学](https://prettier.io/docs/en/option-philosophy.html)，
只支持少数几个选项，以避免关于样式的争论变成关于 Biome 选项的争论。
它故意 [抵制增加新选项的冲动](https://github.com/prettier/prettier/issues/40)，以防止团队中的 [无意义的讨论](https://en.wikipedia.org/wiki/Law_of_triviality)，使他们可以专注于真正重要的事情。

## 选项

Biome 支持的语言无关选项包括：

- 缩进样式（默认：`tab`）：使用空格或制表符进行缩进
- 制表符宽度（默认：`2`）：每个缩进级别的空格数
- 行宽（默认：`80`）：Biome 包装代码的列宽

特定语言也有其他格式化选项。有关详细信息，请参阅 [配置](/reference/configuration) 选项。

## 使用 CLI 使用格式化器

默认情况下，格式化器**检查**代码，并在格式更改时发出诊断：

<PackageManagerBiomeCommand command="format ./src" />

如果你想要**应用**新的格式，传递 `--write` 选项：

<PackageManagerBiomeCommand command="format --write ./src" />

使用 `--help` 标志了解可用选项：

<PackageManagerBiomeCommand command="format --help" />

或者查看 [CLI 参考部分](/reference/cli#biomeformat)。

## 配置

你可能想要使用 `biome.json` [配置 Biome](/reference/configuration/#formatter)。
应用以下默认设置：

```json title="biome.json"
{
  "formatter": {
    "enabled": true,
    "formatWithErrors": false,
    "indentStyle": "tab",
    "indentWidth": 2,
    "lineWidth": 80,
    "ignore": []
  }
}
```

## 忽略代码

有时格式化的代码并不理想。

对于这些情况，你可以使用格式抑制注释：

```js title="example.js"
// biome-ignore format: <explanation>
```

示例：

```js title="example.js"
const expr =
  // biome-ignore format: the array should not be formatted
  [
    (2 * n) / (r - l),
    0,
    (r + l) / (r - l),
    0,
    0,
    (2 * n) / (t - b),
    (t + b) / (t - b),
    0,
    0,
    0,
    -(f + n) / (f - n),
    -(2 * f * n) / (f - n),
    0,
    0,
    -1,
    0,
  ];
```

## 与 Prettier 的差异

有一些与 Prettier 的分歧。

### Prettier 不会取消引用一些有效的 JavaScript 标识符的对象属性。

Prettier 和 Biome 取消引用对象和类属性，这些属性是有效的 JavaScript 标识符。
Prettier [只取消引用有效的 ES5 标识符](https://github.com/prettier/prettier/blob/a5d502513e5de4819a41fd90b9be7247146effc7/src/language-js/utils/index.js#L646)。

这是一个遗留的限制，在 ES2015 现在广泛使用的生态系统中。
因此，我们决定在这里分歧，通过取消引用所有在 ES2015+ 中有效的 JavaScript 标识符。

可能的解决方案是引入一个配置来设置项目使用的 ECMAScript 版本。
然后我们可以根据该版本调整取消引用的行为。
将 ECMAScript 版本设置为 `ES5` 可以匹配 Prettier 的行为。

```js title="example.js"
const obj = {
 'a': true,
 b: true,
 "𐊧": true,
}
```

差异

```js title="exmaple.js" del={4} ins={5}
const obj = {
  a: true,
  b: true,
  "𐊧": true,
  𐊧: true,
};
```


### Prettier 对计算键中的赋值有不一致的行为。

Prettier 和 Biome 将一些赋值表达式封装在括号中，特别是在条件语句中。
这使 Biome 能够识别应该是比较的表达式。

Prettier 的行为不一致，因为它为对象属性的计算键中的赋值添加了括号，但没有为类属性的计算键添加括号，如下例所示：

输入

```js title="example.js"
a = {
  [x = 0]: 1,
}

class C {
  [x = 0] = 1
}
```

差异

```js title="example.js" del={2} ins={3}
a = {
  [(x = 0)]: 1,
  [x = 0]: 1,
};

class C {
  [x = 0] = 1;
}
```

[Playground 链接](https://biomejs.dev/playground?enabledLinting=false&code=YQAgAD0AIAB7AAoAIAAgAFsAeAAgAD0AIAAwAF0AOgAgADEALAAKAH0ACgAKAGMAbABhAHMAcwAgAEMAIAB7AAoAIAAgACAAIABbAHgAIAA9ACAAMABdACAAPQAgADEACgB9AAoA)

为了保持一致，我们决定分歧并省略括号。
或者，我们可以将任何赋值封装在对象或类的计算键中。


### Prettier 即使不需要也会在箭头函数的类型参数后添加尾随逗号。

在某些特定情况下，箭头函数的类型参数列表需要尾随逗号以区分它和 JSX 元素。
当提供默认类型时，不需要这个尾随逗号。
在这里，我们与 Prettier 分歧，因为我们认为它更好地尊重了 Prettier 的原始意图，即只在需要时添加尾随逗号。

输入

```tsx title="example.tsx"
<T = unknown>() => {};
```

差异

```tsx title="example.tsx" del={1} ins={2}
<T = unknown,>() => {};
<T = unknown>() => {};
```


### Prettier 格式化无效的语法

Prettier 的基于 Babel 的 JavaScript 和 TypeScript 解析非常宽松，[允许忽略多个错误](https://github.com/prettier/prettier/blob/e4a74c05f4502dd4ec70495c3130ff08ab088e05/src/language-js/parse/babel.js#L177-L218)。
Biome 的解析器比 Prettier 的解析器有意地更严格。
它正确地识别了以下语法错误：

- 函数不能有重复的修饰符
- 属性修饰符的无效顺序
- 函数声明不允许有主体
- 非抽象类不能有抽象属性
- 一个可选链不能被赋值
- 接口的类型参数不能设置为 `const` 修饰符
- 顶级返回
- 等等。

在 Prettier 中，这些错误不被视为解析错误，AST 仍然被正确地构建，包含适当的节点。
在格式化时，Prettier 将这些节点视为正常节点并相应地格式化它们。

在 Biome 中，解析错误会导致 `Bogus` 节点，这些节点可能包含任意数量的有效节点、无效节点和/或原始字符。
在格式化时，Biome 将 bogus 节点视为实际上的纯文本，将它们原样打印到结果代码中，不进行任何格式化，因为尝试格式化它们可能是不正确的，并可能导致语义变化。

对于类属性，Prettier 的当前解析策略也使用布尔字段作为修饰符，这意味着每种类型的修饰符只能存在一个（访问修饰符存储为单个字符串）。
在打印时，Prettier 查看布尔列表并决定打印哪些修饰符。Biome 保留修饰符列表，这意味着重复的修饰符被保留下来并可以被分析（因此有关重复修饰符和排序的解析错误消息）。
在打印出 bogus 节点时，这个列表保持不变，打印出未格式化的文本会导致这些修饰符继续存在。

Biome 有几种解决这个问题的方法。
一种可能性是在格式化时尝试解释 Bogus 节点并从中构造有效节点。
如果可以构建有效节点，那么它就像正常节点一样格式化，否则，它像现在一样原样打印 bogus 文本。
然而，这是混乱的，并在格式化器中引入了一种无意义的解析逻辑。

另一种选择是在解析器中引入一种 "语法有效的 bogus 节点"，它接受这种纯粹的语义错误（重复的修饰符，非抽象类中的抽象属性）。

它会像正常一样继续构建节点（实际上匹配了 Prettier 中的行为），但是将它们存储在一种新的 bogus 节点中，包括诊断信息。
在格式化时，这些特定的 bogus 节点只会尝试格式化内部节点，然后如果有错误就回退（现有的 `format_or_verbatim` 工具已经可以做到这一点）。
这保持了解析和格式化逻辑的分离，但是为解析器引入了更多的复杂性，允许无效状态被视为半有效。

#### 类属性上的重复修饰符

输入

```ts title="example.ts"
// 多个访问修饰符
class Foo {
  private public a  = 1;
}

// 声明有主体的函数
declare function foo ( ) {  }

// 抽象的无效使用
class Bar {
  abstract  foo  ;
}

// 重复的 Readonly
class Read {
  readonly readonly   x: number;
}
```

差异

```ts title="example.ts" del={3, 8, 13, 19} ins={4, 9, 14, 20}
// 多个访问修饰符
class Foo {
  private a = 1;
  private public a  = 1;
}

// 声明有主体的函数
declare function foo() {};
declare function foo ( ) {  }

// 抽象的无效使用
class Bar {
  abstract foo;
  abstract  foo  ;
}

// 重复的 Readonly
class Read {
  readonly x: number;
  readonly readonly   x: number;
}


#### 对可选链的赋值

输入

```js title="example.js"
(a?.b) = c;
```

差异

```js title="example.js" del={1} ins={2}
a?.b = c;
(a?.b) = c;
```

#### 接口的类型参数的修饰符不正确

输入

```ts title="example.js"
interface L<in const T> {}
```

差异

```ts title="example.js" del={1} ins={2}
interface L<const in T> {}
interface L<in const T> {}
```

#### 顶级返回

```js title="example.js"
return someVeryLongStringA && someVeryLongStringB && someVeryLongStringC && someVeryLongStringD
```

```js title="example.js" del={1, 2, 3, 4, 5, 6} ins={7}
return (
  someVeryLongStringA &&
  someVeryLongStringB &&
  someVeryLongStringC &&
  someVeryLongStringD
);
return someVeryLongStringA && someVeryLongStringB && someVeryLongStringC && someVeryLongStringD
```

#### 错误的自增和自减

输入

```js title="example.js"
(1)++;
```

```js title="example.js" del{1} add={2}
1++;
(1)++;
```

#### 在非抽象类中使用 `abstract` 修饰符

输入

```ts title="example.js"
class C {
  abstract f() : number;
}
```

差异


```ts title="example.js" del{2} add={3}
class C {
  abstract f(): number;
  abstract f() : number;
}
```

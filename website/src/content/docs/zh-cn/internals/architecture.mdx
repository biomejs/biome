---
title: 架构
description: Biome 在幕后是如何工作的。
---

本文档涵盖了 Biome 的一些内部情况，以及它们如何在项目中使用。

## 解析器和 CST

解析器的架构由 [rowan] 的内部分支推动，该库实现了 [Green and Red tree] 模式。

CST (Concrete Syntax Tree) 是一种与 AST (Abstract Syntax Tree) 非常相似的数据结构，它跟踪程序的所有信息，包括 trivia。

**Trivia** 是指对程序运行来说重要的所有信息：
- 空格
- 制表符
- 注释

Trivia 附加到一个节点上。一个节点可以有 leading trivia 和 trailing trivia。如果你从左到右阅读代码，leading trivia 出现在关键字之前，trailing trivia 出现在关键字之后。

Leading trivia 和 trailing trivia 的分类如下：
- 到 token/keyword 的所有 trivia（包括换行符）将是 **leading trivia**；
- 到下一个换行符（但不包括它）的所有内容将是 **trailing trivia**；

给定以下 JavaScript 片段，`// comment 1` 是 token `;` 的 trailing trivia，`// comment 2` 是关键字 `const` 的 leading trivia。以下是 Biome 表示的 CST 的最小化版本：

```js
const a = "foo"; // comment 1
// comment 2
const b = "bar";
```

```
0: JS_MODULE@0..55
    ...
      1: SEMICOLON@15..27 ";" [] [Whitespace(" "), Comments("// comment 1")]
    1: JS_VARIABLE_STATEMENT@27..55
        ...
        1: CONST_KW@27..45 "const" [Newline("\n"), Comments("// comment 2"), Newline("\n")] [Whitespace(" ")]
  3: EOF@55..55 "" [] []
```

CST 从设计上就不直接可访问，开发者可以使用 Red tree 读取其信息，使用从语言的语法自动生成的一些 API。


#### 弹性和可恢复的解析器

为了构建 CST，解析器需要具有错误弹性和可恢复性：
- 弹性：解析器在遇到属于语言的语法错误后能够恢复解析；
- 可恢复：解析器能够**理解**错误发生的位置，并能够通过创建**正确**的信息恢复解析；

解析器的可恢复部分不是一门科学，没有任何铁定的规则。这意味着，根据解析器正在解析的内容和错误发生的位置，解析器可能能够以预期的方式恢复自身。

为了保护消费者不消费错误的语法，解析器还使用 `Bogus` 节点。这些节点用于装饰由语法错误引起的破碎代码。

在以下示例中，`while` 中的括号缺失，尽管解析器能够以良好的方式恢复自身，并能够以一个不错的 CST 表示代码。循环的括号和条件被标记为缺失，代码块被正确解析：


```js
while {}
```

```
JsModule {
  interpreter_token: missing (optional),
  directives: JsDirectiveList [],
  items: JsModuleItemList [
    JsWhileStatement {
      while_token: WHILE_KW@0..6 "while" [] [Whitespace(" ")],
      l_paren_token: missing (required),
      test: missing (required),
      r_paren_token: missing (required),
      body: JsBlockStatement {
        l_curly_token: L_CURLY@6..7 "{" [] [],
        statements: JsStatementList [],
        r_curly_token: R_CURLY@7..8 "}" [] [],
      },
    },
  ],
  eof_token: EOF@8..8 "" [] [],
}
```

这是在解析过程中发出的错误：

```
main.tsx:1:7 parse ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ✖ expected `(` but instead found `{`

  > 1 │ while {}
      │       ^

  ℹ Remove {
```

以下片段则不能这么说。解析器在恢复阶段无法正确理解语法，所以需要依赖 bogus 节点来标记一些语法为错误。注意 `JsBogusStatement`：

```js
function}
```

```
JsModule {
  interpreter_token: missing (optional),
  directives: JsDirectiveList [],
  items: JsModuleItemList [
    TsDeclareFunctionDeclaration {
      async_token: missing (optional),
      function_token: FUNCTION_KW@0..8 "function" [] [],
      id: missing (required),
      type_parameters: missing (optional),
      parameters: missing (required),
      return_type_annotation: missing (optional),
      semicolon_token: missing (optional),
    },
    JsBogusStatement {
      items: [
        R_CURLY@8..9 "}" [] [],
      ],
    },
  ],
  eof_token: EOF@9..9 "" [] [],
}
```

这是我们从解析阶段得到的错误：

```
main.tsx:1:9 parse ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ✖ expected a name for the function in a function declaration, but found none

  > 1 │ function}
      │         ^
```

## 格式化器（WIP）

## Linter（WIP）

## 守护进程（WIP）

Biome 使用服务器-客户端架构来运行其任务。

一个 [守护进程] 是 Biome 在后台启动并用于处理来自编辑器和 CLI 的请求的长时间运行的服务器。


[rowan]: https://github.com/rust-analyzer/rowan
[Green and Red tree]: https://learn.microsoft.com/en-us/archive/blogs/ericlippert/persistence-facades-and-roslyns-red-green-trees
[daemon]: https://en.wikipedia.org/wiki/Daemon_(computing)

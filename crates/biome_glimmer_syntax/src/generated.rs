// This file will be generated by codegen
// For now, create a minimal placeholder

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u16)]
pub enum GlimmerSyntaxKind {
    // Tokens
    WHITESPACE,
    NEWLINE,
    COMMENT,
    IDENT,
    STRING_LITERAL,
    NUMBER_LITERAL,
    TEXT,
    MUSTACHE_COMMENT,

    // Keywords
    AS_KW,
    IF_KW,
    ELSE_KW,
    EACH_KW,
    LET_KW,
    YIELD_KW,
    THIS_KW,
    TRUE_KW,
    FALSE_KW,
    NULL_KW,
    UNDEFINED_KW,

    // Punctuation
    L_CURLY2, // {{
    R_CURLY2, // }}
    L_PAREN,  // (
    R_PAREN,  // )
    L_ANGLE,  // <
    R_ANGLE,  // >
    SLASH,    // /
    DOT,      // .
    PIPE,     // |
    EQ,       // =
    HASH,     // #
    AT,       // @

    // Nodes
    GLIMMER_ROOT,
    GLIMMER_BLOCK,
    GLIMMER_TEXT_NODE,
    GLIMMER_COMMENT_STATEMENT,
    GLIMMER_MUSTACHE_COMMENT_STATEMENT,
    GLIMMER_MUSTACHE_STATEMENT,
    GLIMMER_BLOCK_STATEMENT,
    GLIMMER_ELEMENT_NODE,
    GLIMMER_START_TAG,
    GLIMMER_END_TAG,
    GLIMMER_ATTRIBUTE_NODE,
    GLIMMER_ATTRIBUTE_VALUE,
    GLIMMER_CONCAT_STATEMENT,
    GLIMMER_ELEMENT_MODIFIER,
    GLIMMER_BLOCK_PARAMS,
    GLIMMER_PARAM_NAME,
    GLIMMER_PATH_EXPRESSION,
    GLIMMER_THIS_HEAD,
    GLIMMER_AT_HEAD,
    GLIMMER_VAR_HEAD,
    GLIMMER_SUB_EXPRESSION,
    GLIMMER_HASH,
    GLIMMER_HASH_PAIR,
    GLIMMER_STRING_LITERAL,
    GLIMMER_NUMBER_LITERAL,
    GLIMMER_BOOLEAN_LITERAL,
    GLIMMER_NULL_LITERAL,
    GLIMMER_UNDEFINED_LITERAL,
    GLIMMER_ELSE_BLOCK,

    // Lists
    GLIMMER_STATEMENT_LIST,
    GLIMMER_ATTRIBUTE_LIST,
    GLIMMER_PARAMS_LIST,
    GLIMMER_HASH_PAIR_LIST,

    // Bogus
    GLIMMER_BOGUS,
    GLIMMER_BOGUS_STATEMENT,
    GLIMMER_BOGUS_EXPRESSION,

    // Special
    EOF,
    TOMBSTONE,
    __LAST,
}

impl GlimmerSyntaxKind {
    pub const fn is_list(self) -> bool {
        matches!(
            self,
            Self::GLIMMER_STATEMENT_LIST
                | Self::GLIMMER_ATTRIBUTE_LIST
                | Self::GLIMMER_PARAMS_LIST
                | Self::GLIMMER_HASH_PAIR_LIST
        )
    }

    pub fn to_string(&self) -> Option<&'static str> {
        Some(match self {
            Self::AS_KW => "as",
            Self::IF_KW => "if",
            Self::ELSE_KW => "else",
            Self::EACH_KW => "each",
            Self::LET_KW => "let",
            Self::YIELD_KW => "yield",
            Self::THIS_KW => "this",
            Self::TRUE_KW => "true",
            Self::FALSE_KW => "false",
            Self::NULL_KW => "null",
            Self::UNDEFINED_KW => "undefined",
            _ => return None,
        })
    }
}

use biome_rowan::AstNode;

// Placeholder for generated AST node
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GlimmerRoot {
    syntax: crate::GlimmerSyntaxNode,
}

impl AstNode for GlimmerRoot {
    type Language = crate::GlimmerLanguage;

    const KIND_SET: biome_rowan::SyntaxKindSet<Self::Language> =
        biome_rowan::SyntaxKindSet::from_raw(biome_rowan::RawSyntaxKind(
            GlimmerSyntaxKind::GLIMMER_ROOT as u16,
        ));

    fn can_cast(kind: <Self::Language as biome_rowan::Language>::Kind) -> bool {
        kind == GlimmerSyntaxKind::GLIMMER_ROOT
    }

    fn cast(syntax: biome_rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &biome_rowan::SyntaxNode<Self::Language> {
        &self.syntax
    }

    fn into_syntax(self) -> biome_rowan::SyntaxNode<Self::Language> {
        self.syntax
    }
}

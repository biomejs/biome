//! Generated file, do not edit by hand, see `xtask/codegen`

use biome_css_syntax::{CssSyntaxKind, CssSyntaxKind::*, T, *};
use biome_rowan::{
    AstNode, ParsedChildren, RawNodeSlots, RawSyntaxNode, SyntaxFactory, SyntaxKind,
};
#[derive(Debug)]
pub struct CssSyntaxFactory;
impl SyntaxFactory for CssSyntaxFactory {
    type Kind = CssSyntaxKind;
    #[allow(unused_mut)]
    fn make_syntax(
        kind: Self::Kind,
        children: ParsedChildren<Self::Kind>,
    ) -> RawSyntaxNode<Self::Kind> {
        match kind {
            CSS_BOGUS => RawSyntaxNode::new(kind, children.into_iter().map(Some)),
            CSS_AT_KEYWORD => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<1usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element {
                    if element.kind() == AT_IDENT {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        CSS_AT_KEYWORD.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(CSS_AT_KEYWORD, children)
            }
            CSS_AT_RULE => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<3usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element {
                    if CssAtKeyword::can_cast(element.kind()) {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if let Some(element) = &current_element {
                    if CssAtRuleComponentValue::can_cast(element.kind()) {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if let Some(element) = &current_element {
                    if CssAtRuleContent::can_cast(element.kind()) {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        CSS_AT_RULE.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(CSS_AT_RULE, children)
            }
            CSS_AT_RULE_SEMICOLON => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<1usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element {
                    if element.kind() == T ! [;] {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        CSS_AT_RULE_SEMICOLON.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(CSS_AT_RULE_SEMICOLON, children)
            }
            CSS_BLOCK_DECLARATION_LIST => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<1usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element {
                    if CssDeclarationList::can_cast(element.kind()) {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        CSS_BLOCK_DECLARATION_LIST.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(CSS_BLOCK_DECLARATION_LIST, children)
            }
            CSS_CURLY_BRACKETS_BLOCK => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<3usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element {
                    if element.kind() == T!['{'] {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if let Some(element) = &current_element {
                    if CssCurlyBracketsBlockContent::can_cast(element.kind()) {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if let Some(element) = &current_element {
                    if element.kind() == T!['}'] {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        CSS_CURLY_BRACKETS_BLOCK.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(CSS_CURLY_BRACKETS_BLOCK, children)
            }
            CSS_DECLARATION => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<4usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element {
                    if CssIdentifier::can_cast(element.kind()) {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if let Some(element) = &current_element {
                    if element.kind() == T ! [:] {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if let Some(element) = &current_element {
                    if CssComponentValueList::can_cast(element.kind()) {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if let Some(element) = &current_element {
                    if CssDeclarationImportant::can_cast(element.kind()) {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        CSS_DECLARATION.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(CSS_DECLARATION, children)
            }
            CSS_DECLARATION_IMPORTANT => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<2usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element {
                    if element.kind() == T![!] {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if let Some(element) = &current_element {
                    if element.kind() == T![important] {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        CSS_DECLARATION_IMPORTANT.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(CSS_DECLARATION_IMPORTANT, children)
            }
            CSS_DELIM => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<1usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element {
                    if element.kind() == DELIM {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        CSS_DELIM.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(CSS_DELIM, children)
            }
            CSS_DIMENSION => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<2usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element {
                    if CssNumber::can_cast(element.kind()) {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if let Some(element) = &current_element {
                    if CssIdentifier::can_cast(element.kind()) {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        CSS_DIMENSION.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(CSS_DIMENSION, children)
            }
            CSS_FUNCTION_BLOCK => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<3usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element {
                    if CssFunctionToken::can_cast(element.kind()) {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if let Some(element) = &current_element {
                    if CssComponentValueList::can_cast(element.kind()) {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if let Some(element) = &current_element {
                    if element.kind() == T![')'] {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        CSS_FUNCTION_BLOCK.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(CSS_FUNCTION_BLOCK, children)
            }
            CSS_FUNCTION_TOKEN => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<1usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element {
                    if element.kind() == FUNCTION_TOKEN {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        CSS_FUNCTION_TOKEN.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(CSS_FUNCTION_TOKEN, children)
            }
            CSS_HASH => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<1usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element {
                    if element.kind() == HASH_TOKEN {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(CSS_HASH.to_bogus(), children.into_iter().map(Some));
                }
                slots.into_node(CSS_HASH, children)
            }
            CSS_IDENTIFIER => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<1usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element {
                    if element.kind() == IDENT {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        CSS_IDENTIFIER.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(CSS_IDENTIFIER, children)
            }
            CSS_NUMBER => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<1usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element {
                    if element.kind() == CSS_NUMBER_LITERAL {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        CSS_NUMBER.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(CSS_NUMBER, children)
            }
            CSS_PERCENTAGE => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<2usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element {
                    if CssNumber::can_cast(element.kind()) {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if let Some(element) = &current_element {
                    if element.kind() == T ! [%] {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        CSS_PERCENTAGE.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(CSS_PERCENTAGE, children)
            }
            CSS_PRESERVED_TOKEN_KEY => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<1usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element {
                    if matches!(element.kind(), T![important] | T ! [:] | T ! [,] | T ! [-]) {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        CSS_PRESERVED_TOKEN_KEY.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(CSS_PRESERVED_TOKEN_KEY, children)
            }
            CSS_QUALIFIED_RULE => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<2usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element {
                    if CssQualifiedRulePrelude::can_cast(element.kind()) {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if let Some(element) = &current_element {
                    if CssCurlyBracketsBlock::can_cast(element.kind()) {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        CSS_QUALIFIED_RULE.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(CSS_QUALIFIED_RULE, children)
            }
            CSS_SIMPLE_CURLY_BRACKETS_BLOCK => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<3usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element {
                    if element.kind() == T!['{'] {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if let Some(element) = &current_element {
                    if CssSimpleComponentValueList::can_cast(element.kind()) {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if let Some(element) = &current_element {
                    if element.kind() == T!['}'] {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        CSS_SIMPLE_CURLY_BRACKETS_BLOCK.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(CSS_SIMPLE_CURLY_BRACKETS_BLOCK, children)
            }
            CSS_SIMPLE_PARENTHESES_BLOCK => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<3usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element {
                    if element.kind() == T!['('] {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if let Some(element) = &current_element {
                    if CssSimpleComponentValueList::can_cast(element.kind()) {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if let Some(element) = &current_element {
                    if element.kind() == T![')'] {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        CSS_SIMPLE_PARENTHESES_BLOCK.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(CSS_SIMPLE_PARENTHESES_BLOCK, children)
            }
            CSS_SIMPLE_SQUARE_BRACKETS_BLOCK => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<3usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element {
                    if element.kind() == T!['['] {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if let Some(element) = &current_element {
                    if CssSimpleComponentValueList::can_cast(element.kind()) {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if let Some(element) = &current_element {
                    if element.kind() == T![']'] {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        CSS_SIMPLE_SQUARE_BRACKETS_BLOCK.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(CSS_SIMPLE_SQUARE_BRACKETS_BLOCK, children)
            }
            CSS_STRING => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<1usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element {
                    if element.kind() == CSS_STRING_LITERAL {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        CSS_STRING.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(CSS_STRING, children)
            }
            CSS_STYLE_SHEET => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<3usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element {
                    if element.kind() == T![UNICODE_BOM] {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if let Some(element) = &current_element {
                    if CssStyleSheetContent::can_cast(element.kind()) {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if let Some(element) = &current_element {
                    if element.kind() == T![EOF] {
                        slots.mark_present();
                        current_element = elements.next();
                    }
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        CSS_STYLE_SHEET.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(CSS_STYLE_SHEET, children)
            }
            CSS_AT_RULE_COMPONENT_VALUE => {
                Self::make_node_list_syntax(kind, children, CssComponentValue::can_cast)
            }
            CSS_COMPONENT_VALUE_LIST => {
                Self::make_node_list_syntax(kind, children, CssComponentValue::can_cast)
            }
            CSS_CURLY_BRACKETS_BLOCK_CONTENT => Self::make_node_list_syntax(
                kind,
                children,
                AnyCssCurlyBracketsBlockContent::can_cast,
            ),
            CSS_DECLARATION_LIST => Self::make_separated_list_syntax(
                kind,
                children,
                CssDeclaration::can_cast,
                T ! [;],
                true,
            ),
            CSS_QUALIFIED_RULE_PRELUDE => {
                Self::make_node_list_syntax(kind, children, CssComponentValue::can_cast)
            }
            CSS_SIMPLE_COMPONENT_VALUE_LIST => {
                Self::make_node_list_syntax(kind, children, CssComponentValue::can_cast)
            }
            CSS_STYLE_SHEET_CONTENT => {
                Self::make_node_list_syntax(kind, children, AnyCssStylesheetContent::can_cast)
            }
            _ => unreachable!("Is {:?} a token?", kind),
        }
    }
}

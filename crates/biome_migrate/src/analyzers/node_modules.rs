use crate::{MigrationAction, declare_migration};
use biome_analyze::context::RuleContext;
use biome_analyze::{Ast, Rule, RuleAction, RuleDiagnostic};
use biome_console::markup;
use biome_diagnostics::{Applicability, category};
use biome_json_factory::make::{
    json_array_element_list, json_array_value, json_string_literal, json_string_value, token,
};
use biome_json_syntax::{AnyJsonValue, JsonArrayValue, JsonMember, T};
use biome_rowan::{AstNode, AstSeparatedList, BatchMutationExt, TriviaPieceKind};

declare_migration! {
    pub(crate) NodeModules {
        version: "2.0.0",
        name: "nodeModules",
    }
}

impl Rule for NodeModules {
    type Query = Ast<JsonMember>;
    type State = JsonArrayValue;
    type Signals = Option<Self::State>;
    type Options = ();

    fn run(ctx: &RuleContext<Self>) -> Self::Signals {
        let node = ctx.query();

        let name = node.name().ok()?;
        let text = name.inner_string_text().ok()?;

        if text.text() == "includes" {
            let mut has_node_modules = false;
            let value = node.value().ok()?;
            let values = value.as_json_array_value()?;
            for value in values.elements().iter().flatten() {
                let string_value = value.as_json_string_value()?;
                let value = string_value.inner_string_text().ok()?;
                if value.text().contains("node_modules") {
                    has_node_modules = true;
                    break;
                }
            }
            if !has_node_modules {
                return Some(values.clone());
            }
        }

        None
    }

    fn diagnostic(ctx: &RuleContext<Self>, _: &Self::State) -> Option<RuleDiagnostic> {
        Some(RuleDiagnostic::new(
            category!("migrate"),
            ctx.query().syntax().text_trimmed_range(),
            markup! {
                "The "<Emphasis>"includes"</Emphasis>" property don't include "<Emphasis>"node_modules"</Emphasis>"."
            }
                .to_owned(),
        ))
    }

    fn action(ctx: &RuleContext<Self>, state: &Self::State) -> Option<MigrationAction> {
        let mut mutation = ctx.root().begin();
        let array = state.clone();
        let mut separators = vec![];
        let mut values = array.elements().iter().flatten().collect::<Vec<_>>();
        values.push(AnyJsonValue::JsonStringValue(json_string_value(
            json_string_literal("**/node_modules/**")
                .with_leading_trivia(vec![(TriviaPieceKind::Whitespace, " ")]),
        )));
        for _ in 0..values.len() - 1 {
            separators.push(token(T![,]))
        }

        let new_array = json_array_value(
            array.l_brack_token().ok()?,
            json_array_element_list(values, separators),
            array.r_brack_token().ok()?,
        );

        mutation.replace_node(array, new_array);

        Some(RuleAction::new(
            ctx.metadata().action_category(ctx.category(), ctx.group()),
            Applicability::Always,
            markup! {
                "Add "<Emphasis>"**/node_modules/**"</Emphasis>" to the includes property."
            }
            .to_owned(),
            mutation,
        ))
    }
}

//! Generated file, do not edit by hand, see `xtask/codegen`

#![allow(unused_mut)]
use biome_glimmer_syntax::{GlimmerSyntaxKind, GlimmerSyntaxKind::*, T, *};
use biome_rowan::{
    AstNode, ParsedChildren, RawNodeSlots, RawSyntaxNode, SyntaxFactory, SyntaxKind,
};
#[derive(Debug)]
pub struct GlimmerSyntaxFactory;
impl SyntaxFactory for GlimmerSyntaxFactory {
    type Kind = GlimmerSyntaxKind;
    fn make_syntax(
        kind: Self::Kind,
        children: ParsedChildren<Self::Kind>,
    ) -> RawSyntaxNode<Self::Kind> {
        match kind {
            GLIMMER_BOGUS | GLIMMER_BOGUS_EXPRESSION | GLIMMER_BOGUS_STATEMENT => {
                RawSyntaxNode::new(kind, children.into_iter().map(Some))
            }
            GLIMMER_AT_HEAD => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<2usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && element.kind() == T ! [@]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && element.kind() == IDENT
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        GLIMMER_AT_HEAD.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(GLIMMER_AT_HEAD, children)
            }
            GLIMMER_ATTRIBUTE_NODE => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<3usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && element.kind() == IDENT
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && element.kind() == T ! [=]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && GlimmerAttributeValue::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        GLIMMER_ATTRIBUTE_NODE.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(GLIMMER_ATTRIBUTE_NODE, children)
            }
            GLIMMER_BLOCK => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<2usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && GlimmerBlockParams::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && GlimmerStatementList::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        GLIMMER_BLOCK.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(GLIMMER_BLOCK, children)
            }
            GLIMMER_BLOCK_PARAMS => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<4usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && element.kind() == T![as]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && element.kind() == T ! [|]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && GlimmerParamNameList::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && element.kind() == T ! [|]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        GLIMMER_BLOCK_PARAMS.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(GLIMMER_BLOCK_PARAMS, children)
            }
            GLIMMER_BLOCK_STATEMENT => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<12usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && element.kind() == T![l_curly2]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && element.kind() == T ! [#]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && GlimmerPathExpression::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && GlimmerParamsList::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && GlimmerHash::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && element.kind() == T![r_curly2]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && GlimmerBlock::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && GlimmerElseBlock::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && element.kind() == T![l_curly2]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && element.kind() == T ! [/]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && GlimmerPathExpression::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && element.kind() == T![r_curly2]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        GLIMMER_BLOCK_STATEMENT.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(GLIMMER_BLOCK_STATEMENT, children)
            }
            GLIMMER_BOOLEAN_LITERAL => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<2usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && element.kind() == T![true]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && element.kind() == T![false]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        GLIMMER_BOOLEAN_LITERAL.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(GLIMMER_BOOLEAN_LITERAL, children)
            }
            GLIMMER_COMMENT_STATEMENT => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<1usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && element.kind() == COMMENT
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        GLIMMER_COMMENT_STATEMENT.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(GLIMMER_COMMENT_STATEMENT, children)
            }
            GLIMMER_CONCAT_STATEMENT => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<1usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && GlimmerConcatPartList::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        GLIMMER_CONCAT_STATEMENT.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(GLIMMER_CONCAT_STATEMENT, children)
            }
            GLIMMER_ELEMENT_MODIFIER => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<5usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && element.kind() == T![l_curly2]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && GlimmerPathExpression::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && GlimmerParamsList::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && GlimmerHash::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && element.kind() == T![r_curly2]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        GLIMMER_ELEMENT_MODIFIER.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(GLIMMER_ELEMENT_MODIFIER, children)
            }
            GLIMMER_ELEMENT_NODE => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<3usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && GlimmerStartTag::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && GlimmerStatementList::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && GlimmerEndTag::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        GLIMMER_ELEMENT_NODE.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(GLIMMER_ELEMENT_NODE, children)
            }
            GLIMMER_ELSE_BLOCK => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<6usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && element.kind() == T![l_curly2]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && element.kind() == T![else]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && element.kind() == T![if]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && Expression::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && element.kind() == T![r_curly2]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && GlimmerBlock::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        GLIMMER_ELSE_BLOCK.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(GLIMMER_ELSE_BLOCK, children)
            }
            GLIMMER_END_TAG => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<4usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && element.kind() == T ! [<]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && element.kind() == T ! [/]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && GlimmerPathExpression::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && element.kind() == T ! [>]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        GLIMMER_END_TAG.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(GLIMMER_END_TAG, children)
            }
            GLIMMER_HASH => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<1usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && GlimmerHashPairList::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        GLIMMER_HASH.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(GLIMMER_HASH, children)
            }
            GLIMMER_HASH_PAIR => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<3usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && element.kind() == IDENT
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && element.kind() == T ! [=]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && Expression::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        GLIMMER_HASH_PAIR.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(GLIMMER_HASH_PAIR, children)
            }
            GLIMMER_MUSTACHE_COMMENT_STATEMENT => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<1usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && element.kind() == MUSTACHE_COMMENT
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        GLIMMER_MUSTACHE_COMMENT_STATEMENT.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(GLIMMER_MUSTACHE_COMMENT_STATEMENT, children)
            }
            GLIMMER_MUSTACHE_STATEMENT => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<5usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && element.kind() == T![l_curly2]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && element.kind() == T![l_curly2]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && Expression::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && element.kind() == T![r_curly2]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && element.kind() == T![r_curly2]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        GLIMMER_MUSTACHE_STATEMENT.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(GLIMMER_MUSTACHE_STATEMENT, children)
            }
            GLIMMER_NULL_LITERAL => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<1usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && element.kind() == T![null]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        GLIMMER_NULL_LITERAL.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(GLIMMER_NULL_LITERAL, children)
            }
            GLIMMER_NUMBER_LITERAL => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<1usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && element.kind() == T![number_literal]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        GLIMMER_NUMBER_LITERAL.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(GLIMMER_NUMBER_LITERAL, children)
            }
            GLIMMER_PARAM_NAME => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<1usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && element.kind() == IDENT
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        GLIMMER_PARAM_NAME.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(GLIMMER_PARAM_NAME, children)
            }
            GLIMMER_PATH_EXPRESSION => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<2usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && PathHead::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && GlimmerPathSegmentList::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        GLIMMER_PATH_EXPRESSION.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(GLIMMER_PATH_EXPRESSION, children)
            }
            GLIMMER_PATH_SEGMENT => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<2usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && element.kind() == T ! [.]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && element.kind() == IDENT
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        GLIMMER_PATH_SEGMENT.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(GLIMMER_PATH_SEGMENT, children)
            }
            GLIMMER_ROOT => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<3usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && element.kind() == T![UNICODE_BOM]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && GlimmerStatementList::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && element.kind() == T![EOF]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        GLIMMER_ROOT.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(GLIMMER_ROOT, children)
            }
            GLIMMER_START_TAG => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<7usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && element.kind() == T ! [<]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && GlimmerPathExpression::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && GlimmerAttributeList::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && GlimmerElementModifierList::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && GlimmerBlockParams::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && SelfClosing::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && element.kind() == T ! [>]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        GLIMMER_START_TAG.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(GLIMMER_START_TAG, children)
            }
            GLIMMER_STRING_LITERAL => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<1usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && element.kind() == T![string_literal]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        GLIMMER_STRING_LITERAL.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(GLIMMER_STRING_LITERAL, children)
            }
            GLIMMER_SUB_EXPRESSION => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<5usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && element.kind() == T!['(']
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && GlimmerPathExpression::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && GlimmerParamsList::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && GlimmerHash::can_cast(element.kind())
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if let Some(element) = &current_element
                    && element.kind() == T![')']
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        GLIMMER_SUB_EXPRESSION.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(GLIMMER_SUB_EXPRESSION, children)
            }
            GLIMMER_TEXT_NODE => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<1usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && element.kind() == TEXT
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        GLIMMER_TEXT_NODE.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(GLIMMER_TEXT_NODE, children)
            }
            GLIMMER_THIS_HEAD => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<1usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && element.kind() == T![this]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        GLIMMER_THIS_HEAD.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(GLIMMER_THIS_HEAD, children)
            }
            GLIMMER_UNDEFINED_LITERAL => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<1usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && element.kind() == T![undefined]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        GLIMMER_UNDEFINED_LITERAL.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(GLIMMER_UNDEFINED_LITERAL, children)
            }
            GLIMMER_VAR_HEAD => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<1usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && element.kind() == IDENT
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        GLIMMER_VAR_HEAD.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(GLIMMER_VAR_HEAD, children)
            }
            SELF_CLOSING => {
                let mut elements = (&children).into_iter();
                let mut slots: RawNodeSlots<1usize> = RawNodeSlots::default();
                let mut current_element = elements.next();
                if let Some(element) = &current_element
                    && element.kind() == T ! [/]
                {
                    slots.mark_present();
                    current_element = elements.next();
                }
                slots.next_slot();
                if current_element.is_some() {
                    return RawSyntaxNode::new(
                        SELF_CLOSING.to_bogus(),
                        children.into_iter().map(Some),
                    );
                }
                slots.into_node(SELF_CLOSING, children)
            }
            GLIMMER_ATTRIBUTE_LIST => {
                Self::make_node_list_syntax(kind, children, GlimmerAttributeNode::can_cast)
            }
            GLIMMER_CONCAT_PART_LIST => {
                Self::make_node_list_syntax(kind, children, AnyConcatPart::can_cast)
            }
            GLIMMER_ELEMENT_MODIFIER_LIST => {
                Self::make_node_list_syntax(kind, children, GlimmerElementModifier::can_cast)
            }
            GLIMMER_HASH_PAIR_LIST => {
                Self::make_node_list_syntax(kind, children, GlimmerHashPair::can_cast)
            }
            GLIMMER_PARAM_NAME_LIST => {
                Self::make_node_list_syntax(kind, children, GlimmerParamName::can_cast)
            }
            GLIMMER_PARAMS_LIST => {
                Self::make_node_list_syntax(kind, children, Expression::can_cast)
            }
            GLIMMER_PATH_SEGMENT_LIST => {
                Self::make_node_list_syntax(kind, children, GlimmerPathSegment::can_cast)
            }
            GLIMMER_STATEMENT_LIST => {
                Self::make_node_list_syntax(kind, children, Statement::can_cast)
            }
            _ => unreachable!("Is {:?} a token?", kind),
        }
    }
}

---
source: crates/biome_js_analyze/tests/spec_tests.rs
assertion_line: 86
expression: invalid.js
---
# Input
```jsx
foo.hasOwnProperty("bar");
foo.isPrototypeOf(bar);
foo.propertyIsEnumerable("bar");
foo.bar.hasOwnProperty("bar");
foo.bar.baz.isPrototypeOf("bar");
foo["hasOwnProperty"]("bar");
foo[`isPrototypeOf`]("bar").baz;
foo?.hasOwnProperty(bar);
(foo?.hasOwnProperty)("bar");
foo?.["hasOwnProperty"]("bar");
(foo?.[`hasOwnProperty`])("bar");
Object.hasOwnProperty.call(obj, 'foo');
Object.hasOwnProperty.call(obj, property);
Object.prototype.hasOwnProperty.call(obj, 'foo');
({}).hasOwnProperty.call(obj, 'foo');
Object/* comment */.prototype.hasOwnProperty.call(a, b);
const hasProperty = Object.prototype.hasOwnProperty.call(object, property);
const hasProperty1 = (( Object.prototype.hasOwnProperty.call(object, property) ));
const hasProperty2 = (( Object.prototype.hasOwnProperty.call ))(object, property);
const hasProperty3 = (( Object.prototype.hasOwnProperty )).call(object, property);
const hasProperty4 = (( Object.prototype )).hasOwnProperty.call(object, property);
const hasProperty5 = (( Object )).prototype.hasOwnProperty.call(object, property);
const hasProperty6 = {}.hasOwnProperty.call(object, property);
const hasProperty7 = {}.hasOwnProperty.call(object, property);
const hasProperty8 = (( {}.hasOwnProperty.call(object, property) ));
const hasProperty9 = (( {}.hasOwnProperty.call ))(object, property);
const hasProperty10 = (( {}.hasOwnProperty )).call(object, property);
const hasProperty11 = (( {} )).hasOwnProperty.call(object, property);
function foo(){return {}.hasOwnProperty.call(object, property)}
function foo(){return{}.hasOwnProperty.call(object, property)}
function foo(){return/*comment*/{}.hasOwnProperty.call(object, property)}
async function foo(){return await{}.hasOwnProperty.call(object, property)}
async function foo(){return await/*comment*/{}.hasOwnProperty.call(object, property)}
for (const x of{}.hasOwnProperty.call(object, property).toString());
for (const x of/*comment*/{}.hasOwnProperty.call(object, property).toString());
for (const x in{}.hasOwnProperty.call(object, property).toString());
for (const x in/*comment*/{}.hasOwnProperty.call(object, property).toString());
function foo(){return({}.hasOwnProperty.call)(object, property)}
Object['prototype']['hasOwnProperty']['call'](object, property);
Object[`prototype`][`hasOwnProperty`][`call`](object, property);
Object['hasOwnProperty']['call'](object, property);
Object[`hasOwnProperty`][`call`](object, property);
({})['hasOwnProperty']['call'](object, property);
({})[`hasOwnProperty`][`call`](object, property);
```

# Diagnostics
```
invalid.js:1:5 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
  > 1 │ foo.hasOwnProperty("bar");
      │     ^^^^^^^^^^^^^^
    2 │ foo.isPrototypeOf(bar);
    3 │ foo.propertyIsEnumerable("bar");
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
     1    │ - foo.hasOwnProperty("bar");
        1 │ + Object.hasOwn(foo,·"bar");
     2  2 │   foo.isPrototypeOf(bar);
     3  3 │   foo.propertyIsEnumerable("bar");
  

```

```
invalid.js:2:5 lint/suspicious/noPrototypeBuiltins ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'isPrototypeOf' from target object.
  
    1 │ foo.hasOwnProperty("bar");
  > 2 │ foo.isPrototypeOf(bar);
      │     ^^^^^^^^^^^^^
    3 │ foo.propertyIsEnumerable("bar");
    4 │ foo.bar.hasOwnProperty("bar");
  

```

```
invalid.js:3:5 lint/suspicious/noPrototypeBuiltins ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'propertyIsEnumerable' from target object.
  
    1 │ foo.hasOwnProperty("bar");
    2 │ foo.isPrototypeOf(bar);
  > 3 │ foo.propertyIsEnumerable("bar");
      │     ^^^^^^^^^^^^^^^^^^^^
    4 │ foo.bar.hasOwnProperty("bar");
    5 │ foo.bar.baz.isPrototypeOf("bar");
  

```

```
invalid.js:4:9 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    2 │ foo.isPrototypeOf(bar);
    3 │ foo.propertyIsEnumerable("bar");
  > 4 │ foo.bar.hasOwnProperty("bar");
      │         ^^^^^^^^^^^^^^
    5 │ foo.bar.baz.isPrototypeOf("bar");
    6 │ foo["hasOwnProperty"]("bar");
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
     2  2 │   foo.isPrototypeOf(bar);
     3  3 │   foo.propertyIsEnumerable("bar");
     4    │ - foo.bar.hasOwnProperty("bar");
        4 │ + Object.hasOwn(foo.bar,·"bar");
     5  5 │   foo.bar.baz.isPrototypeOf("bar");
     6  6 │   foo["hasOwnProperty"]("bar");
  

```

```
invalid.js:5:13 lint/suspicious/noPrototypeBuiltins ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'isPrototypeOf' from target object.
  
    3 │ foo.propertyIsEnumerable("bar");
    4 │ foo.bar.hasOwnProperty("bar");
  > 5 │ foo.bar.baz.isPrototypeOf("bar");
      │             ^^^^^^^^^^^^^
    6 │ foo["hasOwnProperty"]("bar");
    7 │ foo[`isPrototypeOf`]("bar").baz;
  

```

```
invalid.js:6:5 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    4 │ foo.bar.hasOwnProperty("bar");
    5 │ foo.bar.baz.isPrototypeOf("bar");
  > 6 │ foo["hasOwnProperty"]("bar");
      │     ^^^^^^^^^^^^^^^^
    7 │ foo[`isPrototypeOf`]("bar").baz;
    8 │ foo?.hasOwnProperty(bar);
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
     4  4 │   foo.bar.hasOwnProperty("bar");
     5  5 │   foo.bar.baz.isPrototypeOf("bar");
     6    │ - foo["hasOwnProperty"]("bar");
        6 │ + Object.hasOwn(foo,·"bar");
     7  7 │   foo[`isPrototypeOf`]("bar").baz;
     8  8 │   foo?.hasOwnProperty(bar);
  

```

```
invalid.js:7:6 lint/suspicious/noPrototypeBuiltins ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'isPrototypeOf' from target object.
  
    5 │ foo.bar.baz.isPrototypeOf("bar");
    6 │ foo["hasOwnProperty"]("bar");
  > 7 │ foo[`isPrototypeOf`]("bar").baz;
      │      ^^^^^^^^^^^^^
    8 │ foo?.hasOwnProperty(bar);
    9 │ (foo?.hasOwnProperty)("bar");
  

```

```
invalid.js:8:6 lint/suspicious/noPrototypeBuiltins ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
     6 │ foo["hasOwnProperty"]("bar");
     7 │ foo[`isPrototypeOf`]("bar").baz;
   > 8 │ foo?.hasOwnProperty(bar);
       │      ^^^^^^^^^^^^^^
     9 │ (foo?.hasOwnProperty)("bar");
    10 │ foo?.["hasOwnProperty"]("bar");
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  

```

```
invalid.js:9:7 lint/suspicious/noPrototypeBuiltins ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
     7 │ foo[`isPrototypeOf`]("bar").baz;
     8 │ foo?.hasOwnProperty(bar);
   > 9 │ (foo?.hasOwnProperty)("bar");
       │       ^^^^^^^^^^^^^^
    10 │ foo?.["hasOwnProperty"]("bar");
    11 │ (foo?.[`hasOwnProperty`])("bar");
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  

```

```
invalid.js:10:7 lint/suspicious/noPrototypeBuiltins ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
     8 │ foo?.hasOwnProperty(bar);
     9 │ (foo?.hasOwnProperty)("bar");
  > 10 │ foo?.["hasOwnProperty"]("bar");
       │       ^^^^^^^^^^^^^^^^
    11 │ (foo?.[`hasOwnProperty`])("bar");
    12 │ Object.hasOwnProperty.call(obj, 'foo');
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  

```

```
invalid.js:11:9 lint/suspicious/noPrototypeBuiltins ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
     9 │ (foo?.hasOwnProperty)("bar");
    10 │ foo?.["hasOwnProperty"]("bar");
  > 11 │ (foo?.[`hasOwnProperty`])("bar");
       │         ^^^^^^^^^^^^^^
    12 │ Object.hasOwnProperty.call(obj, 'foo');
    13 │ Object.hasOwnProperty.call(obj, property);
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  

```

```
invalid.js:12:1 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    10 │ foo?.["hasOwnProperty"]("bar");
    11 │ (foo?.[`hasOwnProperty`])("bar");
  > 12 │ Object.hasOwnProperty.call(obj, 'foo');
       │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    13 │ Object.hasOwnProperty.call(obj, property);
    14 │ Object.prototype.hasOwnProperty.call(obj, 'foo');
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    10 10 │   foo?.["hasOwnProperty"]("bar");
    11 11 │   (foo?.[`hasOwnProperty`])("bar");
    12    │ - Object.hasOwnProperty.call(obj,·'foo');
       12 │ + Object.hasOwn(obj,·'foo');
    13 13 │   Object.hasOwnProperty.call(obj, property);
    14 14 │   Object.prototype.hasOwnProperty.call(obj, 'foo');
  

```

```
invalid.js:13:1 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    11 │ (foo?.[`hasOwnProperty`])("bar");
    12 │ Object.hasOwnProperty.call(obj, 'foo');
  > 13 │ Object.hasOwnProperty.call(obj, property);
       │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    14 │ Object.prototype.hasOwnProperty.call(obj, 'foo');
    15 │ ({}).hasOwnProperty.call(obj, 'foo');
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    11 11 │   (foo?.[`hasOwnProperty`])("bar");
    12 12 │   Object.hasOwnProperty.call(obj, 'foo');
    13    │ - Object.hasOwnProperty.call(obj,·property);
       13 │ + Object.hasOwn(obj,·property);
    14 14 │   Object.prototype.hasOwnProperty.call(obj, 'foo');
    15 15 │   ({}).hasOwnProperty.call(obj, 'foo');
  

```

```
invalid.js:14:1 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    12 │ Object.hasOwnProperty.call(obj, 'foo');
    13 │ Object.hasOwnProperty.call(obj, property);
  > 14 │ Object.prototype.hasOwnProperty.call(obj, 'foo');
       │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    15 │ ({}).hasOwnProperty.call(obj, 'foo');
    16 │ Object/* comment */.prototype.hasOwnProperty.call(a, b);
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    12 12 │   Object.hasOwnProperty.call(obj, 'foo');
    13 13 │   Object.hasOwnProperty.call(obj, property);
    14    │ - Object.prototype.hasOwnProperty.call(obj,·'foo');
       14 │ + Object.hasOwn(obj,·'foo');
    15 15 │   ({}).hasOwnProperty.call(obj, 'foo');
    16 16 │   Object/* comment */.prototype.hasOwnProperty.call(a, b);
  

```

```
invalid.js:15:1 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    13 │ Object.hasOwnProperty.call(obj, property);
    14 │ Object.prototype.hasOwnProperty.call(obj, 'foo');
  > 15 │ ({}).hasOwnProperty.call(obj, 'foo');
       │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    16 │ Object/* comment */.prototype.hasOwnProperty.call(a, b);
    17 │ const hasProperty = Object.prototype.hasOwnProperty.call(object, property);
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    13 13 │   Object.hasOwnProperty.call(obj, property);
    14 14 │   Object.prototype.hasOwnProperty.call(obj, 'foo');
    15    │ - ({}).hasOwnProperty.call(obj,·'foo');
       15 │ + Object.hasOwn(obj,·'foo');
    16 16 │   Object/* comment */.prototype.hasOwnProperty.call(a, b);
    17 17 │   const hasProperty = Object.prototype.hasOwnProperty.call(object, property);
  

```

```
invalid.js:16:1 lint/suspicious/noPrototypeBuiltins ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    14 │ Object.prototype.hasOwnProperty.call(obj, 'foo');
    15 │ ({}).hasOwnProperty.call(obj, 'foo');
  > 16 │ Object/* comment */.prototype.hasOwnProperty.call(a, b);
       │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    17 │ const hasProperty = Object.prototype.hasOwnProperty.call(object, property);
    18 │ const hasProperty1 = (( Object.prototype.hasOwnProperty.call(object, property) ));
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  

```

```
invalid.js:17:21 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    15 │ ({}).hasOwnProperty.call(obj, 'foo');
    16 │ Object/* comment */.prototype.hasOwnProperty.call(a, b);
  > 17 │ const hasProperty = Object.prototype.hasOwnProperty.call(object, property);
       │                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    18 │ const hasProperty1 = (( Object.prototype.hasOwnProperty.call(object, property) ));
    19 │ const hasProperty2 = (( Object.prototype.hasOwnProperty.call ))(object, property);
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    15 15 │   ({}).hasOwnProperty.call(obj, 'foo');
    16 16 │   Object/* comment */.prototype.hasOwnProperty.call(a, b);
    17    │ - const·hasProperty·=·Object.prototype.hasOwnProperty.call(object,·property);
       17 │ + const·hasProperty·=·Object.hasOwn(object,·property);
    18 18 │   const hasProperty1 = (( Object.prototype.hasOwnProperty.call(object, property) ));
    19 19 │   const hasProperty2 = (( Object.prototype.hasOwnProperty.call ))(object, property);
  

```

```
invalid.js:18:25 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    16 │ Object/* comment */.prototype.hasOwnProperty.call(a, b);
    17 │ const hasProperty = Object.prototype.hasOwnProperty.call(object, property);
  > 18 │ const hasProperty1 = (( Object.prototype.hasOwnProperty.call(object, property) ));
       │                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    19 │ const hasProperty2 = (( Object.prototype.hasOwnProperty.call ))(object, property);
    20 │ const hasProperty3 = (( Object.prototype.hasOwnProperty )).call(object, property);
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    16 16 │   Object/* comment */.prototype.hasOwnProperty.call(a, b);
    17 17 │   const hasProperty = Object.prototype.hasOwnProperty.call(object, property);
    18    │ - const·hasProperty1·=·((·Object.prototype.hasOwnProperty.call(object,·property)·));
       18 │ + const·hasProperty1·=·((·Object.hasOwn(object,·property)·));
    19 19 │   const hasProperty2 = (( Object.prototype.hasOwnProperty.call ))(object, property);
    20 20 │   const hasProperty3 = (( Object.prototype.hasOwnProperty )).call(object, property);
  

```

```
invalid.js:19:22 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    17 │ const hasProperty = Object.prototype.hasOwnProperty.call(object, property);
    18 │ const hasProperty1 = (( Object.prototype.hasOwnProperty.call(object, property) ));
  > 19 │ const hasProperty2 = (( Object.prototype.hasOwnProperty.call ))(object, property);
       │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    20 │ const hasProperty3 = (( Object.prototype.hasOwnProperty )).call(object, property);
    21 │ const hasProperty4 = (( Object.prototype )).hasOwnProperty.call(object, property);
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    17 17 │   const hasProperty = Object.prototype.hasOwnProperty.call(object, property);
    18 18 │   const hasProperty1 = (( Object.prototype.hasOwnProperty.call(object, property) ));
    19    │ - const·hasProperty2·=·((·Object.prototype.hasOwnProperty.call·))(object,·property);
       19 │ + const·hasProperty2·=·((·Object.hasOwn·))(object,·property);
    20 20 │   const hasProperty3 = (( Object.prototype.hasOwnProperty )).call(object, property);
    21 21 │   const hasProperty4 = (( Object.prototype )).hasOwnProperty.call(object, property);
  

```

```
invalid.js:20:22 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    18 │ const hasProperty1 = (( Object.prototype.hasOwnProperty.call(object, property) ));
    19 │ const hasProperty2 = (( Object.prototype.hasOwnProperty.call ))(object, property);
  > 20 │ const hasProperty3 = (( Object.prototype.hasOwnProperty )).call(object, property);
       │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    21 │ const hasProperty4 = (( Object.prototype )).hasOwnProperty.call(object, property);
    22 │ const hasProperty5 = (( Object )).prototype.hasOwnProperty.call(object, property);
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    18 18 │   const hasProperty1 = (( Object.prototype.hasOwnProperty.call(object, property) ));
    19 19 │   const hasProperty2 = (( Object.prototype.hasOwnProperty.call ))(object, property);
    20    │ - const·hasProperty3·=·((·Object.prototype.hasOwnProperty·)).call(object,·property);
       20 │ + const·hasProperty3·=·Object.hasOwn(object,·property);
    21 21 │   const hasProperty4 = (( Object.prototype )).hasOwnProperty.call(object, property);
    22 22 │   const hasProperty5 = (( Object )).prototype.hasOwnProperty.call(object, property);
  

```

```
invalid.js:21:22 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    19 │ const hasProperty2 = (( Object.prototype.hasOwnProperty.call ))(object, property);
    20 │ const hasProperty3 = (( Object.prototype.hasOwnProperty )).call(object, property);
  > 21 │ const hasProperty4 = (( Object.prototype )).hasOwnProperty.call(object, property);
       │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    22 │ const hasProperty5 = (( Object )).prototype.hasOwnProperty.call(object, property);
    23 │ const hasProperty6 = {}.hasOwnProperty.call(object, property);
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    19 19 │   const hasProperty2 = (( Object.prototype.hasOwnProperty.call ))(object, property);
    20 20 │   const hasProperty3 = (( Object.prototype.hasOwnProperty )).call(object, property);
    21    │ - const·hasProperty4·=·((·Object.prototype·)).hasOwnProperty.call(object,·property);
       21 │ + const·hasProperty4·=·Object.hasOwn(object,·property);
    22 22 │   const hasProperty5 = (( Object )).prototype.hasOwnProperty.call(object, property);
    23 23 │   const hasProperty6 = {}.hasOwnProperty.call(object, property);
  

```

```
invalid.js:22:22 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    20 │ const hasProperty3 = (( Object.prototype.hasOwnProperty )).call(object, property);
    21 │ const hasProperty4 = (( Object.prototype )).hasOwnProperty.call(object, property);
  > 22 │ const hasProperty5 = (( Object )).prototype.hasOwnProperty.call(object, property);
       │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    23 │ const hasProperty6 = {}.hasOwnProperty.call(object, property);
    24 │ const hasProperty7 = {}.hasOwnProperty.call(object, property);
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    20 20 │   const hasProperty3 = (( Object.prototype.hasOwnProperty )).call(object, property);
    21 21 │   const hasProperty4 = (( Object.prototype )).hasOwnProperty.call(object, property);
    22    │ - const·hasProperty5·=·((·Object·)).prototype.hasOwnProperty.call(object,·property);
       22 │ + const·hasProperty5·=·Object.hasOwn(object,·property);
    23 23 │   const hasProperty6 = {}.hasOwnProperty.call(object, property);
    24 24 │   const hasProperty7 = {}.hasOwnProperty.call(object, property);
  

```

```
invalid.js:23:22 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    21 │ const hasProperty4 = (( Object.prototype )).hasOwnProperty.call(object, property);
    22 │ const hasProperty5 = (( Object )).prototype.hasOwnProperty.call(object, property);
  > 23 │ const hasProperty6 = {}.hasOwnProperty.call(object, property);
       │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    24 │ const hasProperty7 = {}.hasOwnProperty.call(object, property);
    25 │ const hasProperty8 = (( {}.hasOwnProperty.call(object, property) ));
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    21 21 │   const hasProperty4 = (( Object.prototype )).hasOwnProperty.call(object, property);
    22 22 │   const hasProperty5 = (( Object )).prototype.hasOwnProperty.call(object, property);
    23    │ - const·hasProperty6·=·{}.hasOwnProperty.call(object,·property);
       23 │ + const·hasProperty6·=·Object.hasOwn(object,·property);
    24 24 │   const hasProperty7 = {}.hasOwnProperty.call(object, property);
    25 25 │   const hasProperty8 = (( {}.hasOwnProperty.call(object, property) ));
  

```

```
invalid.js:24:22 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    22 │ const hasProperty5 = (( Object )).prototype.hasOwnProperty.call(object, property);
    23 │ const hasProperty6 = {}.hasOwnProperty.call(object, property);
  > 24 │ const hasProperty7 = {}.hasOwnProperty.call(object, property);
       │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    25 │ const hasProperty8 = (( {}.hasOwnProperty.call(object, property) ));
    26 │ const hasProperty9 = (( {}.hasOwnProperty.call ))(object, property);
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    22 22 │   const hasProperty5 = (( Object )).prototype.hasOwnProperty.call(object, property);
    23 23 │   const hasProperty6 = {}.hasOwnProperty.call(object, property);
    24    │ - const·hasProperty7·=·{}.hasOwnProperty.call(object,·property);
       24 │ + const·hasProperty7·=·Object.hasOwn(object,·property);
    25 25 │   const hasProperty8 = (( {}.hasOwnProperty.call(object, property) ));
    26 26 │   const hasProperty9 = (( {}.hasOwnProperty.call ))(object, property);
  

```

```
invalid.js:25:25 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    23 │ const hasProperty6 = {}.hasOwnProperty.call(object, property);
    24 │ const hasProperty7 = {}.hasOwnProperty.call(object, property);
  > 25 │ const hasProperty8 = (( {}.hasOwnProperty.call(object, property) ));
       │                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    26 │ const hasProperty9 = (( {}.hasOwnProperty.call ))(object, property);
    27 │ const hasProperty10 = (( {}.hasOwnProperty )).call(object, property);
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    23 23 │   const hasProperty6 = {}.hasOwnProperty.call(object, property);
    24 24 │   const hasProperty7 = {}.hasOwnProperty.call(object, property);
    25    │ - const·hasProperty8·=·((·{}.hasOwnProperty.call(object,·property)·));
       25 │ + const·hasProperty8·=·((·Object.hasOwn(object,·property)·));
    26 26 │   const hasProperty9 = (( {}.hasOwnProperty.call ))(object, property);
    27 27 │   const hasProperty10 = (( {}.hasOwnProperty )).call(object, property);
  

```

```
invalid.js:26:22 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    24 │ const hasProperty7 = {}.hasOwnProperty.call(object, property);
    25 │ const hasProperty8 = (( {}.hasOwnProperty.call(object, property) ));
  > 26 │ const hasProperty9 = (( {}.hasOwnProperty.call ))(object, property);
       │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    27 │ const hasProperty10 = (( {}.hasOwnProperty )).call(object, property);
    28 │ const hasProperty11 = (( {} )).hasOwnProperty.call(object, property);
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    24 24 │   const hasProperty7 = {}.hasOwnProperty.call(object, property);
    25 25 │   const hasProperty8 = (( {}.hasOwnProperty.call(object, property) ));
    26    │ - const·hasProperty9·=·((·{}.hasOwnProperty.call·))(object,·property);
       26 │ + const·hasProperty9·=·((·Object.hasOwn·))(object,·property);
    27 27 │   const hasProperty10 = (( {}.hasOwnProperty )).call(object, property);
    28 28 │   const hasProperty11 = (( {} )).hasOwnProperty.call(object, property);
  

```

```
invalid.js:27:23 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    25 │ const hasProperty8 = (( {}.hasOwnProperty.call(object, property) ));
    26 │ const hasProperty9 = (( {}.hasOwnProperty.call ))(object, property);
  > 27 │ const hasProperty10 = (( {}.hasOwnProperty )).call(object, property);
       │                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    28 │ const hasProperty11 = (( {} )).hasOwnProperty.call(object, property);
    29 │ function foo(){return {}.hasOwnProperty.call(object, property)}
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    25 25 │   const hasProperty8 = (( {}.hasOwnProperty.call(object, property) ));
    26 26 │   const hasProperty9 = (( {}.hasOwnProperty.call ))(object, property);
    27    │ - const·hasProperty10·=·((·{}.hasOwnProperty·)).call(object,·property);
       27 │ + const·hasProperty10·=·Object.hasOwn(object,·property);
    28 28 │   const hasProperty11 = (( {} )).hasOwnProperty.call(object, property);
    29 29 │   function foo(){return {}.hasOwnProperty.call(object, property)}
  

```

```
invalid.js:28:23 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    26 │ const hasProperty9 = (( {}.hasOwnProperty.call ))(object, property);
    27 │ const hasProperty10 = (( {}.hasOwnProperty )).call(object, property);
  > 28 │ const hasProperty11 = (( {} )).hasOwnProperty.call(object, property);
       │                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    29 │ function foo(){return {}.hasOwnProperty.call(object, property)}
    30 │ function foo(){return{}.hasOwnProperty.call(object, property)}
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    26 26 │   const hasProperty9 = (( {}.hasOwnProperty.call ))(object, property);
    27 27 │   const hasProperty10 = (( {}.hasOwnProperty )).call(object, property);
    28    │ - const·hasProperty11·=·((·{}·)).hasOwnProperty.call(object,·property);
       28 │ + const·hasProperty11·=·Object.hasOwn(object,·property);
    29 29 │   function foo(){return {}.hasOwnProperty.call(object, property)}
    30 30 │   function foo(){return{}.hasOwnProperty.call(object, property)}
  

```

```
invalid.js:29:23 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    27 │ const hasProperty10 = (( {}.hasOwnProperty )).call(object, property);
    28 │ const hasProperty11 = (( {} )).hasOwnProperty.call(object, property);
  > 29 │ function foo(){return {}.hasOwnProperty.call(object, property)}
       │                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    30 │ function foo(){return{}.hasOwnProperty.call(object, property)}
    31 │ function foo(){return/*comment*/{}.hasOwnProperty.call(object, property)}
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    27 27 │   const hasProperty10 = (( {}.hasOwnProperty )).call(object, property);
    28 28 │   const hasProperty11 = (( {} )).hasOwnProperty.call(object, property);
    29    │ - function·foo(){return·{}.hasOwnProperty.call(object,·property)}
       29 │ + function·foo(){return··Object.hasOwn(object,·property)}
    30 30 │   function foo(){return{}.hasOwnProperty.call(object, property)}
    31 31 │   function foo(){return/*comment*/{}.hasOwnProperty.call(object, property)}
  

```

```
invalid.js:30:22 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    28 │ const hasProperty11 = (( {} )).hasOwnProperty.call(object, property);
    29 │ function foo(){return {}.hasOwnProperty.call(object, property)}
  > 30 │ function foo(){return{}.hasOwnProperty.call(object, property)}
       │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    31 │ function foo(){return/*comment*/{}.hasOwnProperty.call(object, property)}
    32 │ async function foo(){return await{}.hasOwnProperty.call(object, property)}
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    28 28 │   const hasProperty11 = (( {} )).hasOwnProperty.call(object, property);
    29 29 │   function foo(){return {}.hasOwnProperty.call(object, property)}
    30    │ - function·foo(){return{}.hasOwnProperty.call(object,·property)}
       30 │ + function·foo(){return·Object.hasOwn(object,·property)}
    31 31 │   function foo(){return/*comment*/{}.hasOwnProperty.call(object, property)}
    32 32 │   async function foo(){return await{}.hasOwnProperty.call(object, property)}
  

```

```
invalid.js:31:33 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    29 │ function foo(){return {}.hasOwnProperty.call(object, property)}
    30 │ function foo(){return{}.hasOwnProperty.call(object, property)}
  > 31 │ function foo(){return/*comment*/{}.hasOwnProperty.call(object, property)}
       │                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    32 │ async function foo(){return await{}.hasOwnProperty.call(object, property)}
    33 │ async function foo(){return await/*comment*/{}.hasOwnProperty.call(object, property)}
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    29 29 │   function foo(){return {}.hasOwnProperty.call(object, property)}
    30 30 │   function foo(){return{}.hasOwnProperty.call(object, property)}
    31    │ - function·foo(){return/*comment*/{}.hasOwnProperty.call(object,·property)}
       31 │ + function·foo(){return/*comment*/·Object.hasOwn(object,·property)}
    32 32 │   async function foo(){return await{}.hasOwnProperty.call(object, property)}
    33 33 │   async function foo(){return await/*comment*/{}.hasOwnProperty.call(object, property)}
  

```

```
invalid.js:32:34 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    30 │ function foo(){return{}.hasOwnProperty.call(object, property)}
    31 │ function foo(){return/*comment*/{}.hasOwnProperty.call(object, property)}
  > 32 │ async function foo(){return await{}.hasOwnProperty.call(object, property)}
       │                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    33 │ async function foo(){return await/*comment*/{}.hasOwnProperty.call(object, property)}
    34 │ for (const x of{}.hasOwnProperty.call(object, property).toString());
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    30 30 │   function foo(){return{}.hasOwnProperty.call(object, property)}
    31 31 │   function foo(){return/*comment*/{}.hasOwnProperty.call(object, property)}
    32    │ - async·function·foo(){return·await{}.hasOwnProperty.call(object,·property)}
       32 │ + async·function·foo(){return·awaitObject.hasOwn(object,·property)}
    33 33 │   async function foo(){return await/*comment*/{}.hasOwnProperty.call(object, property)}
    34 34 │   for (const x of{}.hasOwnProperty.call(object, property).toString());
  

```

```
invalid.js:33:45 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    31 │ function foo(){return/*comment*/{}.hasOwnProperty.call(object, property)}
    32 │ async function foo(){return await{}.hasOwnProperty.call(object, property)}
  > 33 │ async function foo(){return await/*comment*/{}.hasOwnProperty.call(object, property)}
       │                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    34 │ for (const x of{}.hasOwnProperty.call(object, property).toString());
    35 │ for (const x of/*comment*/{}.hasOwnProperty.call(object, property).toString());
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    31 31 │   function foo(){return/*comment*/{}.hasOwnProperty.call(object, property)}
    32 32 │   async function foo(){return await{}.hasOwnProperty.call(object, property)}
    33    │ - async·function·foo(){return·await/*comment*/{}.hasOwnProperty.call(object,·property)}
       33 │ + async·function·foo(){return·await/*comment*/Object.hasOwn(object,·property)}
    34 34 │   for (const x of{}.hasOwnProperty.call(object, property).toString());
    35 35 │   for (const x of/*comment*/{}.hasOwnProperty.call(object, property).toString());
  

```

```
invalid.js:34:16 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    32 │ async function foo(){return await{}.hasOwnProperty.call(object, property)}
    33 │ async function foo(){return await/*comment*/{}.hasOwnProperty.call(object, property)}
  > 34 │ for (const x of{}.hasOwnProperty.call(object, property).toString());
       │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    35 │ for (const x of/*comment*/{}.hasOwnProperty.call(object, property).toString());
    36 │ for (const x in{}.hasOwnProperty.call(object, property).toString());
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    32 32 │   async function foo(){return await{}.hasOwnProperty.call(object, property)}
    33 33 │   async function foo(){return await/*comment*/{}.hasOwnProperty.call(object, property)}
    34    │ - for·(const·x·of{}.hasOwnProperty.call(object,·property).toString());
       34 │ + for·(const·x·of·Object.hasOwn(object,·property).toString());
    35 35 │   for (const x of/*comment*/{}.hasOwnProperty.call(object, property).toString());
    36 36 │   for (const x in{}.hasOwnProperty.call(object, property).toString());
  

```

```
invalid.js:35:27 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    33 │ async function foo(){return await/*comment*/{}.hasOwnProperty.call(object, property)}
    34 │ for (const x of{}.hasOwnProperty.call(object, property).toString());
  > 35 │ for (const x of/*comment*/{}.hasOwnProperty.call(object, property).toString());
       │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    36 │ for (const x in{}.hasOwnProperty.call(object, property).toString());
    37 │ for (const x in/*comment*/{}.hasOwnProperty.call(object, property).toString());
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    33 33 │   async function foo(){return await/*comment*/{}.hasOwnProperty.call(object, property)}
    34 34 │   for (const x of{}.hasOwnProperty.call(object, property).toString());
    35    │ - for·(const·x·of/*comment*/{}.hasOwnProperty.call(object,·property).toString());
       35 │ + for·(const·x·of/*comment*/·Object.hasOwn(object,·property).toString());
    36 36 │   for (const x in{}.hasOwnProperty.call(object, property).toString());
    37 37 │   for (const x in/*comment*/{}.hasOwnProperty.call(object, property).toString());
  

```

```
invalid.js:36:16 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    34 │ for (const x of{}.hasOwnProperty.call(object, property).toString());
    35 │ for (const x of/*comment*/{}.hasOwnProperty.call(object, property).toString());
  > 36 │ for (const x in{}.hasOwnProperty.call(object, property).toString());
       │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    37 │ for (const x in/*comment*/{}.hasOwnProperty.call(object, property).toString());
    38 │ function foo(){return({}.hasOwnProperty.call)(object, property)}
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    34 34 │   for (const x of{}.hasOwnProperty.call(object, property).toString());
    35 35 │   for (const x of/*comment*/{}.hasOwnProperty.call(object, property).toString());
    36    │ - for·(const·x·in{}.hasOwnProperty.call(object,·property).toString());
       36 │ + for·(const·x·in·Object.hasOwn(object,·property).toString());
    37 37 │   for (const x in/*comment*/{}.hasOwnProperty.call(object, property).toString());
    38 38 │   function foo(){return({}.hasOwnProperty.call)(object, property)}
  

```

```
invalid.js:37:27 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    35 │ for (const x of/*comment*/{}.hasOwnProperty.call(object, property).toString());
    36 │ for (const x in{}.hasOwnProperty.call(object, property).toString());
  > 37 │ for (const x in/*comment*/{}.hasOwnProperty.call(object, property).toString());
       │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    38 │ function foo(){return({}.hasOwnProperty.call)(object, property)}
    39 │ Object['prototype']['hasOwnProperty']['call'](object, property);
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    35 35 │   for (const x of/*comment*/{}.hasOwnProperty.call(object, property).toString());
    36 36 │   for (const x in{}.hasOwnProperty.call(object, property).toString());
    37    │ - for·(const·x·in/*comment*/{}.hasOwnProperty.call(object,·property).toString());
       37 │ + for·(const·x·in/*comment*/·Object.hasOwn(object,·property).toString());
    38 38 │   function foo(){return({}.hasOwnProperty.call)(object, property)}
    39 39 │   Object['prototype']['hasOwnProperty']['call'](object, property);
  

```

```
invalid.js:38:22 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    36 │ for (const x in{}.hasOwnProperty.call(object, property).toString());
    37 │ for (const x in/*comment*/{}.hasOwnProperty.call(object, property).toString());
  > 38 │ function foo(){return({}.hasOwnProperty.call)(object, property)}
       │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    39 │ Object['prototype']['hasOwnProperty']['call'](object, property);
    40 │ Object[`prototype`][`hasOwnProperty`][`call`](object, property);
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    36 36 │   for (const x in{}.hasOwnProperty.call(object, property).toString());
    37 37 │   for (const x in/*comment*/{}.hasOwnProperty.call(object, property).toString());
    38    │ - function·foo(){return({}.hasOwnProperty.call)(object,·property)}
       38 │ + function·foo(){return(Object.hasOwn)(object,·property)}
    39 39 │   Object['prototype']['hasOwnProperty']['call'](object, property);
    40 40 │   Object[`prototype`][`hasOwnProperty`][`call`](object, property);
  

```

```
invalid.js:39:1 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    37 │ for (const x in/*comment*/{}.hasOwnProperty.call(object, property).toString());
    38 │ function foo(){return({}.hasOwnProperty.call)(object, property)}
  > 39 │ Object['prototype']['hasOwnProperty']['call'](object, property);
       │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    40 │ Object[`prototype`][`hasOwnProperty`][`call`](object, property);
    41 │ Object['hasOwnProperty']['call'](object, property);
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    37 37 │   for (const x in/*comment*/{}.hasOwnProperty.call(object, property).toString());
    38 38 │   function foo(){return({}.hasOwnProperty.call)(object, property)}
    39    │ - Object['prototype']['hasOwnProperty']['call'](object,·property);
       39 │ + Object.hasOwn(object,·property);
    40 40 │   Object[`prototype`][`hasOwnProperty`][`call`](object, property);
    41 41 │   Object['hasOwnProperty']['call'](object, property);
  

```

```
invalid.js:40:1 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    38 │ function foo(){return({}.hasOwnProperty.call)(object, property)}
    39 │ Object['prototype']['hasOwnProperty']['call'](object, property);
  > 40 │ Object[`prototype`][`hasOwnProperty`][`call`](object, property);
       │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    41 │ Object['hasOwnProperty']['call'](object, property);
    42 │ Object[`hasOwnProperty`][`call`](object, property);
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    38 38 │   function foo(){return({}.hasOwnProperty.call)(object, property)}
    39 39 │   Object['prototype']['hasOwnProperty']['call'](object, property);
    40    │ - Object[`prototype`][`hasOwnProperty`][`call`](object,·property);
       40 │ + Object.hasOwn(object,·property);
    41 41 │   Object['hasOwnProperty']['call'](object, property);
    42 42 │   Object[`hasOwnProperty`][`call`](object, property);
  

```

```
invalid.js:41:1 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    39 │ Object['prototype']['hasOwnProperty']['call'](object, property);
    40 │ Object[`prototype`][`hasOwnProperty`][`call`](object, property);
  > 41 │ Object['hasOwnProperty']['call'](object, property);
       │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    42 │ Object[`hasOwnProperty`][`call`](object, property);
    43 │ ({})['hasOwnProperty']['call'](object, property);
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    39 39 │   Object['prototype']['hasOwnProperty']['call'](object, property);
    40 40 │   Object[`prototype`][`hasOwnProperty`][`call`](object, property);
    41    │ - Object['hasOwnProperty']['call'](object,·property);
       41 │ + Object.hasOwn(object,·property);
    42 42 │   Object[`hasOwnProperty`][`call`](object, property);
    43 43 │   ({})['hasOwnProperty']['call'](object, property);
  

```

```
invalid.js:42:1 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    40 │ Object[`prototype`][`hasOwnProperty`][`call`](object, property);
    41 │ Object['hasOwnProperty']['call'](object, property);
  > 42 │ Object[`hasOwnProperty`][`call`](object, property);
       │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    43 │ ({})['hasOwnProperty']['call'](object, property);
    44 │ ({})[`hasOwnProperty`][`call`](object, property);
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    40 40 │   Object[`prototype`][`hasOwnProperty`][`call`](object, property);
    41 41 │   Object['hasOwnProperty']['call'](object, property);
    42    │ - Object[`hasOwnProperty`][`call`](object,·property);
       42 │ + Object.hasOwn(object,·property);
    43 43 │   ({})['hasOwnProperty']['call'](object, property);
    44 44 │   ({})[`hasOwnProperty`][`call`](object, property);
  

```

```
invalid.js:43:1 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    41 │ Object['hasOwnProperty']['call'](object, property);
    42 │ Object[`hasOwnProperty`][`call`](object, property);
  > 43 │ ({})['hasOwnProperty']['call'](object, property);
       │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    44 │ ({})[`hasOwnProperty`][`call`](object, property);
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    41 41 │   Object['hasOwnProperty']['call'](object, property);
    42 42 │   Object[`hasOwnProperty`][`call`](object, property);
    43    │ - ({})['hasOwnProperty']['call'](object,·property);
       43 │ + Object.hasOwn(object,·property);
    44 44 │   ({})[`hasOwnProperty`][`call`](object, property);
  

```

```
invalid.js:44:1 lint/suspicious/noPrototypeBuiltins  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Do not access Object.prototype method 'hasOwnProperty' from target object.
  
    42 │ Object[`hasOwnProperty`][`call`](object, property);
    43 │ ({})['hasOwnProperty']['call'](object, property);
  > 44 │ ({})[`hasOwnProperty`][`call`](object, property);
       │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
  i It's recommended using Object.hasOwn() instead of using Object.hasOwnProperty().
  
  i See MDN web docs for more details.
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    42 42 │   Object[`hasOwnProperty`][`call`](object, property);
    43 43 │   ({})['hasOwnProperty']['call'](object, property);
    44    │ - ({})[`hasOwnProperty`][`call`](object,·property);
       44 │ + Object.hasOwn(object,·property);
  

```

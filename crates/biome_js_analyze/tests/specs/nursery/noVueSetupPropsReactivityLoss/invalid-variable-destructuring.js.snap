---
source: crates/biome_js_analyze/tests/spec_tests.rs
expression: invalid-variable-destructuring.js
---
# Input
```js
// Variable destructuring patterns that lose reactivity

// const destructuring
export default {
  setup(props) {
    const { foo, bar } = props;
    return () => h('div', foo + bar)
  }
}

// let destructuring
export default {
  setup(props) {
    let { foo, bar } = props;
    return () => h('div', foo + bar)
  }
}

// var destructuring  
export default {
  setup(props) {
    var { foo, bar } = props;
    return () => h('div', foo + bar)
  }
}

// Assignment destructuring
export default {
  setup(props) {
    let foo, bar;
    ({ foo, bar } = props);
    return () => h('div', foo + bar)
  }
}

// Deep destructuring
export default {
  setup(props) {
    const { user: { name, age } } = props;
    return () => h('div', name + age)
  }
}

// Array destructuring from props property
export default {
  setup(props) {
    const [first, second] = props.items;
    return () => h('div', first + second)
  }
}
```

# Diagnostics
```
invalid-variable-destructuring.js:6:11 lint/nursery/noVueSetupPropsReactivityLoss ━━━━━━━━━━━━━━━━━━

  i Destructuring `props` in the root scope of `setup` loses reactivity.
  
    4 │ export default {
    5 │   setup(props) {
  > 6 │     const { foo, bar } = props;
      │           ^^^^^^^^^^^^
    7 │     return () => h('div', foo + bar)
    8 │   }
  
  i The `props` parameter is defined here.
  
    3 │ // const destructuring
    4 │ export default {
  > 5 │   setup(props) {
      │         ^^^^^
    6 │     const { foo, bar } = props;
    7 │     return () => h('div', foo + bar)
  
  i To preserve reactivity, access props as properties: `props.propertyName`.
  
  i Alternatively, use `toRefs(props)` or `toRef(props, 'key')` to create reactive refs.
  

```

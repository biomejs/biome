---
source: crates/biome_js_analyze/tests/spec_tests.rs
expression: invalid.js
---
# Input
```js
// Simple case: parameter only used in recursion
function factorial(n, acc) {
    if (n === 0) return 1;
    return factorial(n - 1, acc);
}

// Multiple parameters only in recursion
function fn(a, b, c) {
    if (a === 0) return 0;
    return fn(a - 1, b, c);
}

// Arrow function with recursion
const countdown = (n, acc) => {
    if (n === 0) return 0;
    return countdown(n - 1, acc);
};

// Method in class
class Counter {
    count(n, acc) {
        if (n === 0) return 0;
        return this.count(n - 1, acc);
    }
}

// Parameter with arithmetic in recursion
function countdown(n, step) {
    if (n === 0) return 0;
    return countdown(n - step, step);
}

// Multiple operations
function compute(a, b) {
    if (a === 0) return 0;
    return compute(a - 1, b * 2 + 1);
}

// Unary operations
function negate(n, flag) {
    if (n === 0) return 0;
    return negate(n - 1, !flag);
}

// Object method
const obj = {
    count(n, step) {
        if (n === 0) return 0;
        return this.count(n - step, step);
    }
};

```

# Diagnostics
```
invalid.js:2:23 lint/nursery/noParametersOnlyUsedInRecursion  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! This parameter is only used in recursive calls.
  
    1 │ // Simple case: parameter only used in recursion
  > 2 │ function factorial(n, acc) {
      │                       ^^^
    3 │     if (n === 0) return 1;
    4 │     return factorial(n - 1, acc);
  
  i Parameters that are only used in recursive calls are effectively unused and can be removed.
  
  i If the parameter is needed for the recursion to work, consider if the function can be refactored to avoid it.
  
  i Unsafe fix: If this is intentional, prepend acc with an underscore.
  
     1  1 │   // Simple case: parameter only used in recursion
     2    │ - function·factorial(n,·acc)·{
        2 │ + function·factorial(n,·_acc)·{
     3  3 │       if (n === 0) return 1;
     4    │ - ····return·factorial(n·-·1,·acc);
        4 │ + ····return·factorial(n·-·1,·_acc);
     5  5 │   }
     6  6 │   
  

```

```
invalid.js:8:16 lint/nursery/noParametersOnlyUsedInRecursion  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! This parameter is only used in recursive calls.
  
     7 │ // Multiple parameters only in recursion
   > 8 │ function fn(a, b, c) {
       │                ^
     9 │     if (a === 0) return 0;
    10 │     return fn(a - 1, b, c);
  
  i Parameters that are only used in recursive calls are effectively unused and can be removed.
  
  i If the parameter is needed for the recursion to work, consider if the function can be refactored to avoid it.
  
  i Unsafe fix: If this is intentional, prepend b with an underscore.
  
     6  6 │   
     7  7 │   // Multiple parameters only in recursion
     8    │ - function·fn(a,·b,·c)·{
        8 │ + function·fn(a,·_b,·c)·{
     9  9 │       if (a === 0) return 0;
    10    │ - ····return·fn(a·-·1,·b,·c);
       10 │ + ····return·fn(a·-·1,·_b,·c);
    11 11 │   }
    12 12 │   
  

```

```
invalid.js:8:19 lint/nursery/noParametersOnlyUsedInRecursion  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! This parameter is only used in recursive calls.
  
     7 │ // Multiple parameters only in recursion
   > 8 │ function fn(a, b, c) {
       │                   ^
     9 │     if (a === 0) return 0;
    10 │     return fn(a - 1, b, c);
  
  i Parameters that are only used in recursive calls are effectively unused and can be removed.
  
  i If the parameter is needed for the recursion to work, consider if the function can be refactored to avoid it.
  
  i Unsafe fix: If this is intentional, prepend c with an underscore.
  
     6  6 │   
     7  7 │   // Multiple parameters only in recursion
     8    │ - function·fn(a,·b,·c)·{
        8 │ + function·fn(a,·b,·_c)·{
     9  9 │       if (a === 0) return 0;
    10    │ - ····return·fn(a·-·1,·b,·c);
       10 │ + ····return·fn(a·-·1,·b,·_c);
    11 11 │   }
    12 12 │   
  

```

```
invalid.js:21:14 lint/nursery/noParametersOnlyUsedInRecursion  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! This parameter is only used in recursive calls.
  
    19 │ // Method in class
    20 │ class Counter {
  > 21 │     count(n, acc) {
       │              ^^^
    22 │         if (n === 0) return 0;
    23 │         return this.count(n - 1, acc);
  
  i Parameters that are only used in recursive calls are effectively unused and can be removed.
  
  i If the parameter is needed for the recursion to work, consider if the function can be refactored to avoid it.
  
  i Unsafe fix: If this is intentional, prepend acc with an underscore.
  
    19 19 │   // Method in class
    20 20 │   class Counter {
    21    │ - ····count(n,·acc)·{
       21 │ + ····count(n,·_acc)·{
    22 22 │           if (n === 0) return 0;
    23    │ - ········return·this.count(n·-·1,·acc);
       23 │ + ········return·this.count(n·-·1,·_acc);
    24 24 │       }
    25 25 │   }
  

```

```
invalid.js:28:23 lint/nursery/noParametersOnlyUsedInRecursion  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! This parameter is only used in recursive calls.
  
    27 │ // Parameter with arithmetic in recursion
  > 28 │ function countdown(n, step) {
       │                       ^^^^
    29 │     if (n === 0) return 0;
    30 │     return countdown(n - step, step);
  
  i Parameters that are only used in recursive calls are effectively unused and can be removed.
  
  i If the parameter is needed for the recursion to work, consider if the function can be refactored to avoid it.
  
  i Unsafe fix: If this is intentional, prepend step with an underscore.
  
    26 26 │   
    27 27 │   // Parameter with arithmetic in recursion
    28    │ - function·countdown(n,·step)·{
       28 │ + function·countdown(n,·_step)·{
    29 29 │       if (n === 0) return 0;
    30    │ - ····return·countdown(n·-·step,·step);
       30 │ + ····return·countdown(n·-·_step,·_step);
    31 31 │   }
    32 32 │   
  

```

```
invalid.js:34:21 lint/nursery/noParametersOnlyUsedInRecursion  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! This parameter is only used in recursive calls.
  
    33 │ // Multiple operations
  > 34 │ function compute(a, b) {
       │                     ^
    35 │     if (a === 0) return 0;
    36 │     return compute(a - 1, b * 2 + 1);
  
  i Parameters that are only used in recursive calls are effectively unused and can be removed.
  
  i If the parameter is needed for the recursion to work, consider if the function can be refactored to avoid it.
  
  i Unsafe fix: If this is intentional, prepend b with an underscore.
  
    32 32 │   
    33 33 │   // Multiple operations
    34    │ - function·compute(a,·b)·{
       34 │ + function·compute(a,·_b)·{
    35 35 │       if (a === 0) return 0;
    36    │ - ····return·compute(a·-·1,·b·*·2·+·1);
       36 │ + ····return·compute(a·-·1,·_b·*·2·+·1);
    37 37 │   }
    38 38 │   
  

```

```
invalid.js:40:20 lint/nursery/noParametersOnlyUsedInRecursion  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! This parameter is only used in recursive calls.
  
    39 │ // Unary operations
  > 40 │ function negate(n, flag) {
       │                    ^^^^
    41 │     if (n === 0) return 0;
    42 │     return negate(n - 1, !flag);
  
  i Parameters that are only used in recursive calls are effectively unused and can be removed.
  
  i If the parameter is needed for the recursion to work, consider if the function can be refactored to avoid it.
  
  i Unsafe fix: If this is intentional, prepend flag with an underscore.
  
    38 38 │   
    39 39 │   // Unary operations
    40    │ - function·negate(n,·flag)·{
       40 │ + function·negate(n,·_flag)·{
    41 41 │       if (n === 0) return 0;
    42    │ - ····return·negate(n·-·1,·!flag);
       42 │ + ····return·negate(n·-·1,·!_flag);
    43 43 │   }
    44 44 │   
  

```

```
invalid.js:47:14 lint/nursery/noParametersOnlyUsedInRecursion  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! This parameter is only used in recursive calls.
  
    45 │ // Object method
    46 │ const obj = {
  > 47 │     count(n, step) {
       │              ^^^^
    48 │         if (n === 0) return 0;
    49 │         return this.count(n - step, step);
  
  i Parameters that are only used in recursive calls are effectively unused and can be removed.
  
  i If the parameter is needed for the recursion to work, consider if the function can be refactored to avoid it.
  
  i Unsafe fix: If this is intentional, prepend step with an underscore.
  
    45 45 │   // Object method
    46 46 │   const obj = {
    47    │ - ····count(n,·step)·{
       47 │ + ····count(n,·_step)·{
    48 48 │           if (n === 0) return 0;
    49    │ - ········return·this.count(n·-·step,·step);
       49 │ + ········return·this.count(n·-·_step,·_step);
    50 50 │       }
    51 51 │   };
  

```

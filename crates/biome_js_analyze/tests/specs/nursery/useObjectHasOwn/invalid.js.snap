---
source: crates/biome_js_analyze/tests/spec_tests.rs
assertion_line: 86
expression: invalid.js
---
# Input
```jsx
Object.hasOwnProperty.call(obj, 'foo');
Object.hasOwnProperty.call(obj, property);
Object.prototype.hasOwnProperty.call(obj, 'foo');
({}).hasOwnProperty.call(obj, 'foo');
Object/* comment */.prototype.hasOwnProperty.call(a, b);
const hasProperty = Object.prototype.hasOwnProperty.call(object, property);
const hasProperty1 = (( Object.prototype.hasOwnProperty.call(object, property) ));
const hasProperty2 = (( Object.prototype.hasOwnProperty.call ))(object, property);
const hasProperty3 = (( Object.prototype.hasOwnProperty )).call(object, property);
const hasProperty4 = (( Object.prototype )).hasOwnProperty.call(object, property);
const hasProperty5 = (( Object )).prototype.hasOwnProperty.call(object, property);
const hasProperty6 = {}.hasOwnProperty.call(object, property);
const hasProperty7 = {}.hasOwnProperty.call(object, property);
const hasProperty8 = (( {}.hasOwnProperty.call(object, property) ));
const hasProperty9 = (( {}.hasOwnProperty.call ))(object, property);
const hasProperty10 = (( {}.hasOwnProperty )).call(object, property);
const hasProperty11 = (( {} )).hasOwnProperty.call(object, property);
function foo(){return {}.hasOwnProperty.call(object, property)}
function foo(){return{}.hasOwnProperty.call(object, property)}
function foo(){return/*comment*/{}.hasOwnProperty.call(object, property)}
async function foo(){return await{}.hasOwnProperty.call(object, property)}
async function foo(){return await/*comment*/{}.hasOwnProperty.call(object, property)}
for (const x of{}.hasOwnProperty.call(object, property).toString());
for (const x of/*comment*/{}.hasOwnProperty.call(object, property).toString());
for (const x in{}.hasOwnProperty.call(object, property).toString());
for (const x in/*comment*/{}.hasOwnProperty.call(object, property).toString());
function foo(){return({}.hasOwnProperty.call)(object, property)}
Object['prototype']['hasOwnProperty']['call'](object, property);
Object[`prototype`][`hasOwnProperty`][`call`](object, property);
Object['hasOwnProperty']['call'](object, property);
Object[`hasOwnProperty`][`call`](object, property);
({})['hasOwnProperty']['call'](object, property);
({})[`hasOwnProperty`][`call`](object, property);

```

# Diagnostics
```
invalid.js:1:1 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
  > 1 │ Object.hasOwnProperty.call(obj, 'foo');
      │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    2 │ Object.hasOwnProperty.call(obj, property);
    3 │ Object.prototype.hasOwnProperty.call(obj, 'foo');
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
     1    │ - Object.hasOwnProperty.call(obj,·'foo');
        1 │ + Object.hasOwn(obj,·'foo');
     2  2 │   Object.hasOwnProperty.call(obj, property);
     3  3 │   Object.prototype.hasOwnProperty.call(obj, 'foo');
  

```

```
invalid.js:2:1 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
    1 │ Object.hasOwnProperty.call(obj, 'foo');
  > 2 │ Object.hasOwnProperty.call(obj, property);
      │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    3 │ Object.prototype.hasOwnProperty.call(obj, 'foo');
    4 │ ({}).hasOwnProperty.call(obj, 'foo');
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
     1  1 │   Object.hasOwnProperty.call(obj, 'foo');
     2    │ - Object.hasOwnProperty.call(obj,·property);
        2 │ + Object.hasOwn(obj,·property);
     3  3 │   Object.prototype.hasOwnProperty.call(obj, 'foo');
     4  4 │   ({}).hasOwnProperty.call(obj, 'foo');
  

```

```
invalid.js:3:1 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
    1 │ Object.hasOwnProperty.call(obj, 'foo');
    2 │ Object.hasOwnProperty.call(obj, property);
  > 3 │ Object.prototype.hasOwnProperty.call(obj, 'foo');
      │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    4 │ ({}).hasOwnProperty.call(obj, 'foo');
    5 │ Object/* comment */.prototype.hasOwnProperty.call(a, b);
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
     1  1 │   Object.hasOwnProperty.call(obj, 'foo');
     2  2 │   Object.hasOwnProperty.call(obj, property);
     3    │ - Object.prototype.hasOwnProperty.call(obj,·'foo');
        3 │ + Object.hasOwn(obj,·'foo');
     4  4 │   ({}).hasOwnProperty.call(obj, 'foo');
     5  5 │   Object/* comment */.prototype.hasOwnProperty.call(a, b);
  

```

```
invalid.js:4:1 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
    2 │ Object.hasOwnProperty.call(obj, property);
    3 │ Object.prototype.hasOwnProperty.call(obj, 'foo');
  > 4 │ ({}).hasOwnProperty.call(obj, 'foo');
      │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    5 │ Object/* comment */.prototype.hasOwnProperty.call(a, b);
    6 │ const hasProperty = Object.prototype.hasOwnProperty.call(object, property);
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
     2  2 │   Object.hasOwnProperty.call(obj, property);
     3  3 │   Object.prototype.hasOwnProperty.call(obj, 'foo');
     4    │ - ({}).hasOwnProperty.call(obj,·'foo');
        4 │ + Object.hasOwn(obj,·'foo');
     5  5 │   Object/* comment */.prototype.hasOwnProperty.call(a, b);
     6  6 │   const hasProperty = Object.prototype.hasOwnProperty.call(object, property);
  

```

```
invalid.js:5:1 lint/nursery/useObjectHasOwn ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
    3 │ Object.prototype.hasOwnProperty.call(obj, 'foo');
    4 │ ({}).hasOwnProperty.call(obj, 'foo');
  > 5 │ Object/* comment */.prototype.hasOwnProperty.call(a, b);
      │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    6 │ const hasProperty = Object.prototype.hasOwnProperty.call(object, property);
    7 │ const hasProperty1 = (( Object.prototype.hasOwnProperty.call(object, property) ));
  

```

```
invalid.js:6:21 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
    4 │ ({}).hasOwnProperty.call(obj, 'foo');
    5 │ Object/* comment */.prototype.hasOwnProperty.call(a, b);
  > 6 │ const hasProperty = Object.prototype.hasOwnProperty.call(object, property);
      │                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    7 │ const hasProperty1 = (( Object.prototype.hasOwnProperty.call(object, property) ));
    8 │ const hasProperty2 = (( Object.prototype.hasOwnProperty.call ))(object, property);
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
     4  4 │   ({}).hasOwnProperty.call(obj, 'foo');
     5  5 │   Object/* comment */.prototype.hasOwnProperty.call(a, b);
     6    │ - const·hasProperty·=·Object.prototype.hasOwnProperty.call(object,·property);
        6 │ + const·hasProperty·=·Object.hasOwn(object,·property);
     7  7 │   const hasProperty1 = (( Object.prototype.hasOwnProperty.call(object, property) ));
     8  8 │   const hasProperty2 = (( Object.prototype.hasOwnProperty.call ))(object, property);
  

```

```
invalid.js:7:25 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
    5 │ Object/* comment */.prototype.hasOwnProperty.call(a, b);
    6 │ const hasProperty = Object.prototype.hasOwnProperty.call(object, property);
  > 7 │ const hasProperty1 = (( Object.prototype.hasOwnProperty.call(object, property) ));
      │                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    8 │ const hasProperty2 = (( Object.prototype.hasOwnProperty.call ))(object, property);
    9 │ const hasProperty3 = (( Object.prototype.hasOwnProperty )).call(object, property);
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
     5  5 │   Object/* comment */.prototype.hasOwnProperty.call(a, b);
     6  6 │   const hasProperty = Object.prototype.hasOwnProperty.call(object, property);
     7    │ - const·hasProperty1·=·((·Object.prototype.hasOwnProperty.call(object,·property)·));
        7 │ + const·hasProperty1·=·((·Object.hasOwn(object,·property)·));
     8  8 │   const hasProperty2 = (( Object.prototype.hasOwnProperty.call ))(object, property);
     9  9 │   const hasProperty3 = (( Object.prototype.hasOwnProperty )).call(object, property);
  

```

```
invalid.js:8:22 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
     6 │ const hasProperty = Object.prototype.hasOwnProperty.call(object, property);
     7 │ const hasProperty1 = (( Object.prototype.hasOwnProperty.call(object, property) ));
   > 8 │ const hasProperty2 = (( Object.prototype.hasOwnProperty.call ))(object, property);
       │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     9 │ const hasProperty3 = (( Object.prototype.hasOwnProperty )).call(object, property);
    10 │ const hasProperty4 = (( Object.prototype )).hasOwnProperty.call(object, property);
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
     6  6 │   const hasProperty = Object.prototype.hasOwnProperty.call(object, property);
     7  7 │   const hasProperty1 = (( Object.prototype.hasOwnProperty.call(object, property) ));
     8    │ - const·hasProperty2·=·((·Object.prototype.hasOwnProperty.call·))(object,·property);
        8 │ + const·hasProperty2·=·((·Object.hasOwn·))(object,·property);
     9  9 │   const hasProperty3 = (( Object.prototype.hasOwnProperty )).call(object, property);
    10 10 │   const hasProperty4 = (( Object.prototype )).hasOwnProperty.call(object, property);
  

```

```
invalid.js:9:22 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
     7 │ const hasProperty1 = (( Object.prototype.hasOwnProperty.call(object, property) ));
     8 │ const hasProperty2 = (( Object.prototype.hasOwnProperty.call ))(object, property);
   > 9 │ const hasProperty3 = (( Object.prototype.hasOwnProperty )).call(object, property);
       │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    10 │ const hasProperty4 = (( Object.prototype )).hasOwnProperty.call(object, property);
    11 │ const hasProperty5 = (( Object )).prototype.hasOwnProperty.call(object, property);
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
     7  7 │   const hasProperty1 = (( Object.prototype.hasOwnProperty.call(object, property) ));
     8  8 │   const hasProperty2 = (( Object.prototype.hasOwnProperty.call ))(object, property);
     9    │ - const·hasProperty3·=·((·Object.prototype.hasOwnProperty·)).call(object,·property);
        9 │ + const·hasProperty3·=·Object.hasOwn(object,·property);
    10 10 │   const hasProperty4 = (( Object.prototype )).hasOwnProperty.call(object, property);
    11 11 │   const hasProperty5 = (( Object )).prototype.hasOwnProperty.call(object, property);
  

```

```
invalid.js:10:22 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
     8 │ const hasProperty2 = (( Object.prototype.hasOwnProperty.call ))(object, property);
     9 │ const hasProperty3 = (( Object.prototype.hasOwnProperty )).call(object, property);
  > 10 │ const hasProperty4 = (( Object.prototype )).hasOwnProperty.call(object, property);
       │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    11 │ const hasProperty5 = (( Object )).prototype.hasOwnProperty.call(object, property);
    12 │ const hasProperty6 = {}.hasOwnProperty.call(object, property);
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
     8  8 │   const hasProperty2 = (( Object.prototype.hasOwnProperty.call ))(object, property);
     9  9 │   const hasProperty3 = (( Object.prototype.hasOwnProperty )).call(object, property);
    10    │ - const·hasProperty4·=·((·Object.prototype·)).hasOwnProperty.call(object,·property);
       10 │ + const·hasProperty4·=·Object.hasOwn(object,·property);
    11 11 │   const hasProperty5 = (( Object )).prototype.hasOwnProperty.call(object, property);
    12 12 │   const hasProperty6 = {}.hasOwnProperty.call(object, property);
  

```

```
invalid.js:11:22 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
     9 │ const hasProperty3 = (( Object.prototype.hasOwnProperty )).call(object, property);
    10 │ const hasProperty4 = (( Object.prototype )).hasOwnProperty.call(object, property);
  > 11 │ const hasProperty5 = (( Object )).prototype.hasOwnProperty.call(object, property);
       │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    12 │ const hasProperty6 = {}.hasOwnProperty.call(object, property);
    13 │ const hasProperty7 = {}.hasOwnProperty.call(object, property);
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
     9  9 │   const hasProperty3 = (( Object.prototype.hasOwnProperty )).call(object, property);
    10 10 │   const hasProperty4 = (( Object.prototype )).hasOwnProperty.call(object, property);
    11    │ - const·hasProperty5·=·((·Object·)).prototype.hasOwnProperty.call(object,·property);
       11 │ + const·hasProperty5·=·Object.hasOwn(object,·property);
    12 12 │   const hasProperty6 = {}.hasOwnProperty.call(object, property);
    13 13 │   const hasProperty7 = {}.hasOwnProperty.call(object, property);
  

```

```
invalid.js:12:22 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
    10 │ const hasProperty4 = (( Object.prototype )).hasOwnProperty.call(object, property);
    11 │ const hasProperty5 = (( Object )).prototype.hasOwnProperty.call(object, property);
  > 12 │ const hasProperty6 = {}.hasOwnProperty.call(object, property);
       │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    13 │ const hasProperty7 = {}.hasOwnProperty.call(object, property);
    14 │ const hasProperty8 = (( {}.hasOwnProperty.call(object, property) ));
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    10 10 │   const hasProperty4 = (( Object.prototype )).hasOwnProperty.call(object, property);
    11 11 │   const hasProperty5 = (( Object )).prototype.hasOwnProperty.call(object, property);
    12    │ - const·hasProperty6·=·{}.hasOwnProperty.call(object,·property);
       12 │ + const·hasProperty6·=·Object.hasOwn(object,·property);
    13 13 │   const hasProperty7 = {}.hasOwnProperty.call(object, property);
    14 14 │   const hasProperty8 = (( {}.hasOwnProperty.call(object, property) ));
  

```

```
invalid.js:13:22 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
    11 │ const hasProperty5 = (( Object )).prototype.hasOwnProperty.call(object, property);
    12 │ const hasProperty6 = {}.hasOwnProperty.call(object, property);
  > 13 │ const hasProperty7 = {}.hasOwnProperty.call(object, property);
       │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    14 │ const hasProperty8 = (( {}.hasOwnProperty.call(object, property) ));
    15 │ const hasProperty9 = (( {}.hasOwnProperty.call ))(object, property);
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    11 11 │   const hasProperty5 = (( Object )).prototype.hasOwnProperty.call(object, property);
    12 12 │   const hasProperty6 = {}.hasOwnProperty.call(object, property);
    13    │ - const·hasProperty7·=·{}.hasOwnProperty.call(object,·property);
       13 │ + const·hasProperty7·=·Object.hasOwn(object,·property);
    14 14 │   const hasProperty8 = (( {}.hasOwnProperty.call(object, property) ));
    15 15 │   const hasProperty9 = (( {}.hasOwnProperty.call ))(object, property);
  

```

```
invalid.js:14:25 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
    12 │ const hasProperty6 = {}.hasOwnProperty.call(object, property);
    13 │ const hasProperty7 = {}.hasOwnProperty.call(object, property);
  > 14 │ const hasProperty8 = (( {}.hasOwnProperty.call(object, property) ));
       │                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    15 │ const hasProperty9 = (( {}.hasOwnProperty.call ))(object, property);
    16 │ const hasProperty10 = (( {}.hasOwnProperty )).call(object, property);
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    12 12 │   const hasProperty6 = {}.hasOwnProperty.call(object, property);
    13 13 │   const hasProperty7 = {}.hasOwnProperty.call(object, property);
    14    │ - const·hasProperty8·=·((·{}.hasOwnProperty.call(object,·property)·));
       14 │ + const·hasProperty8·=·((·Object.hasOwn(object,·property)·));
    15 15 │   const hasProperty9 = (( {}.hasOwnProperty.call ))(object, property);
    16 16 │   const hasProperty10 = (( {}.hasOwnProperty )).call(object, property);
  

```

```
invalid.js:15:22 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
    13 │ const hasProperty7 = {}.hasOwnProperty.call(object, property);
    14 │ const hasProperty8 = (( {}.hasOwnProperty.call(object, property) ));
  > 15 │ const hasProperty9 = (( {}.hasOwnProperty.call ))(object, property);
       │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    16 │ const hasProperty10 = (( {}.hasOwnProperty )).call(object, property);
    17 │ const hasProperty11 = (( {} )).hasOwnProperty.call(object, property);
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    13 13 │   const hasProperty7 = {}.hasOwnProperty.call(object, property);
    14 14 │   const hasProperty8 = (( {}.hasOwnProperty.call(object, property) ));
    15    │ - const·hasProperty9·=·((·{}.hasOwnProperty.call·))(object,·property);
       15 │ + const·hasProperty9·=·((·Object.hasOwn·))(object,·property);
    16 16 │   const hasProperty10 = (( {}.hasOwnProperty )).call(object, property);
    17 17 │   const hasProperty11 = (( {} )).hasOwnProperty.call(object, property);
  

```

```
invalid.js:16:23 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
    14 │ const hasProperty8 = (( {}.hasOwnProperty.call(object, property) ));
    15 │ const hasProperty9 = (( {}.hasOwnProperty.call ))(object, property);
  > 16 │ const hasProperty10 = (( {}.hasOwnProperty )).call(object, property);
       │                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    17 │ const hasProperty11 = (( {} )).hasOwnProperty.call(object, property);
    18 │ function foo(){return {}.hasOwnProperty.call(object, property)}
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    14 14 │   const hasProperty8 = (( {}.hasOwnProperty.call(object, property) ));
    15 15 │   const hasProperty9 = (( {}.hasOwnProperty.call ))(object, property);
    16    │ - const·hasProperty10·=·((·{}.hasOwnProperty·)).call(object,·property);
       16 │ + const·hasProperty10·=·Object.hasOwn(object,·property);
    17 17 │   const hasProperty11 = (( {} )).hasOwnProperty.call(object, property);
    18 18 │   function foo(){return {}.hasOwnProperty.call(object, property)}
  

```

```
invalid.js:17:23 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
    15 │ const hasProperty9 = (( {}.hasOwnProperty.call ))(object, property);
    16 │ const hasProperty10 = (( {}.hasOwnProperty )).call(object, property);
  > 17 │ const hasProperty11 = (( {} )).hasOwnProperty.call(object, property);
       │                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    18 │ function foo(){return {}.hasOwnProperty.call(object, property)}
    19 │ function foo(){return{}.hasOwnProperty.call(object, property)}
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    15 15 │   const hasProperty9 = (( {}.hasOwnProperty.call ))(object, property);
    16 16 │   const hasProperty10 = (( {}.hasOwnProperty )).call(object, property);
    17    │ - const·hasProperty11·=·((·{}·)).hasOwnProperty.call(object,·property);
       17 │ + const·hasProperty11·=·Object.hasOwn(object,·property);
    18 18 │   function foo(){return {}.hasOwnProperty.call(object, property)}
    19 19 │   function foo(){return{}.hasOwnProperty.call(object, property)}
  

```

```
invalid.js:18:23 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
    16 │ const hasProperty10 = (( {}.hasOwnProperty )).call(object, property);
    17 │ const hasProperty11 = (( {} )).hasOwnProperty.call(object, property);
  > 18 │ function foo(){return {}.hasOwnProperty.call(object, property)}
       │                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    19 │ function foo(){return{}.hasOwnProperty.call(object, property)}
    20 │ function foo(){return/*comment*/{}.hasOwnProperty.call(object, property)}
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    16 16 │   const hasProperty10 = (( {}.hasOwnProperty )).call(object, property);
    17 17 │   const hasProperty11 = (( {} )).hasOwnProperty.call(object, property);
    18    │ - function·foo(){return·{}.hasOwnProperty.call(object,·property)}
       18 │ + function·foo(){return··Object.hasOwn(object,·property)}
    19 19 │   function foo(){return{}.hasOwnProperty.call(object, property)}
    20 20 │   function foo(){return/*comment*/{}.hasOwnProperty.call(object, property)}
  

```

```
invalid.js:19:22 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
    17 │ const hasProperty11 = (( {} )).hasOwnProperty.call(object, property);
    18 │ function foo(){return {}.hasOwnProperty.call(object, property)}
  > 19 │ function foo(){return{}.hasOwnProperty.call(object, property)}
       │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    20 │ function foo(){return/*comment*/{}.hasOwnProperty.call(object, property)}
    21 │ async function foo(){return await{}.hasOwnProperty.call(object, property)}
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    17 17 │   const hasProperty11 = (( {} )).hasOwnProperty.call(object, property);
    18 18 │   function foo(){return {}.hasOwnProperty.call(object, property)}
    19    │ - function·foo(){return{}.hasOwnProperty.call(object,·property)}
       19 │ + function·foo(){return·Object.hasOwn(object,·property)}
    20 20 │   function foo(){return/*comment*/{}.hasOwnProperty.call(object, property)}
    21 21 │   async function foo(){return await{}.hasOwnProperty.call(object, property)}
  

```

```
invalid.js:20:33 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
    18 │ function foo(){return {}.hasOwnProperty.call(object, property)}
    19 │ function foo(){return{}.hasOwnProperty.call(object, property)}
  > 20 │ function foo(){return/*comment*/{}.hasOwnProperty.call(object, property)}
       │                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    21 │ async function foo(){return await{}.hasOwnProperty.call(object, property)}
    22 │ async function foo(){return await/*comment*/{}.hasOwnProperty.call(object, property)}
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    18 18 │   function foo(){return {}.hasOwnProperty.call(object, property)}
    19 19 │   function foo(){return{}.hasOwnProperty.call(object, property)}
    20    │ - function·foo(){return/*comment*/{}.hasOwnProperty.call(object,·property)}
       20 │ + function·foo(){return/*comment*/·Object.hasOwn(object,·property)}
    21 21 │   async function foo(){return await{}.hasOwnProperty.call(object, property)}
    22 22 │   async function foo(){return await/*comment*/{}.hasOwnProperty.call(object, property)}
  

```

```
invalid.js:21:34 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
    19 │ function foo(){return{}.hasOwnProperty.call(object, property)}
    20 │ function foo(){return/*comment*/{}.hasOwnProperty.call(object, property)}
  > 21 │ async function foo(){return await{}.hasOwnProperty.call(object, property)}
       │                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    22 │ async function foo(){return await/*comment*/{}.hasOwnProperty.call(object, property)}
    23 │ for (const x of{}.hasOwnProperty.call(object, property).toString());
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    19 19 │   function foo(){return{}.hasOwnProperty.call(object, property)}
    20 20 │   function foo(){return/*comment*/{}.hasOwnProperty.call(object, property)}
    21    │ - async·function·foo(){return·await{}.hasOwnProperty.call(object,·property)}
       21 │ + async·function·foo(){return·awaitObject.hasOwn(object,·property)}
    22 22 │   async function foo(){return await/*comment*/{}.hasOwnProperty.call(object, property)}
    23 23 │   for (const x of{}.hasOwnProperty.call(object, property).toString());
  

```

```
invalid.js:22:45 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
    20 │ function foo(){return/*comment*/{}.hasOwnProperty.call(object, property)}
    21 │ async function foo(){return await{}.hasOwnProperty.call(object, property)}
  > 22 │ async function foo(){return await/*comment*/{}.hasOwnProperty.call(object, property)}
       │                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    23 │ for (const x of{}.hasOwnProperty.call(object, property).toString());
    24 │ for (const x of/*comment*/{}.hasOwnProperty.call(object, property).toString());
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    20 20 │   function foo(){return/*comment*/{}.hasOwnProperty.call(object, property)}
    21 21 │   async function foo(){return await{}.hasOwnProperty.call(object, property)}
    22    │ - async·function·foo(){return·await/*comment*/{}.hasOwnProperty.call(object,·property)}
       22 │ + async·function·foo(){return·await/*comment*/Object.hasOwn(object,·property)}
    23 23 │   for (const x of{}.hasOwnProperty.call(object, property).toString());
    24 24 │   for (const x of/*comment*/{}.hasOwnProperty.call(object, property).toString());
  

```

```
invalid.js:23:16 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
    21 │ async function foo(){return await{}.hasOwnProperty.call(object, property)}
    22 │ async function foo(){return await/*comment*/{}.hasOwnProperty.call(object, property)}
  > 23 │ for (const x of{}.hasOwnProperty.call(object, property).toString());
       │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    24 │ for (const x of/*comment*/{}.hasOwnProperty.call(object, property).toString());
    25 │ for (const x in{}.hasOwnProperty.call(object, property).toString());
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    21 21 │   async function foo(){return await{}.hasOwnProperty.call(object, property)}
    22 22 │   async function foo(){return await/*comment*/{}.hasOwnProperty.call(object, property)}
    23    │ - for·(const·x·of{}.hasOwnProperty.call(object,·property).toString());
       23 │ + for·(const·x·of·Object.hasOwn(object,·property).toString());
    24 24 │   for (const x of/*comment*/{}.hasOwnProperty.call(object, property).toString());
    25 25 │   for (const x in{}.hasOwnProperty.call(object, property).toString());
  

```

```
invalid.js:24:27 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
    22 │ async function foo(){return await/*comment*/{}.hasOwnProperty.call(object, property)}
    23 │ for (const x of{}.hasOwnProperty.call(object, property).toString());
  > 24 │ for (const x of/*comment*/{}.hasOwnProperty.call(object, property).toString());
       │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    25 │ for (const x in{}.hasOwnProperty.call(object, property).toString());
    26 │ for (const x in/*comment*/{}.hasOwnProperty.call(object, property).toString());
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    22 22 │   async function foo(){return await/*comment*/{}.hasOwnProperty.call(object, property)}
    23 23 │   for (const x of{}.hasOwnProperty.call(object, property).toString());
    24    │ - for·(const·x·of/*comment*/{}.hasOwnProperty.call(object,·property).toString());
       24 │ + for·(const·x·of/*comment*/·Object.hasOwn(object,·property).toString());
    25 25 │   for (const x in{}.hasOwnProperty.call(object, property).toString());
    26 26 │   for (const x in/*comment*/{}.hasOwnProperty.call(object, property).toString());
  

```

```
invalid.js:25:16 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
    23 │ for (const x of{}.hasOwnProperty.call(object, property).toString());
    24 │ for (const x of/*comment*/{}.hasOwnProperty.call(object, property).toString());
  > 25 │ for (const x in{}.hasOwnProperty.call(object, property).toString());
       │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    26 │ for (const x in/*comment*/{}.hasOwnProperty.call(object, property).toString());
    27 │ function foo(){return({}.hasOwnProperty.call)(object, property)}
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    23 23 │   for (const x of{}.hasOwnProperty.call(object, property).toString());
    24 24 │   for (const x of/*comment*/{}.hasOwnProperty.call(object, property).toString());
    25    │ - for·(const·x·in{}.hasOwnProperty.call(object,·property).toString());
       25 │ + for·(const·x·in·Object.hasOwn(object,·property).toString());
    26 26 │   for (const x in/*comment*/{}.hasOwnProperty.call(object, property).toString());
    27 27 │   function foo(){return({}.hasOwnProperty.call)(object, property)}
  

```

```
invalid.js:26:27 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
    24 │ for (const x of/*comment*/{}.hasOwnProperty.call(object, property).toString());
    25 │ for (const x in{}.hasOwnProperty.call(object, property).toString());
  > 26 │ for (const x in/*comment*/{}.hasOwnProperty.call(object, property).toString());
       │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    27 │ function foo(){return({}.hasOwnProperty.call)(object, property)}
    28 │ Object['prototype']['hasOwnProperty']['call'](object, property);
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    24 24 │   for (const x of/*comment*/{}.hasOwnProperty.call(object, property).toString());
    25 25 │   for (const x in{}.hasOwnProperty.call(object, property).toString());
    26    │ - for·(const·x·in/*comment*/{}.hasOwnProperty.call(object,·property).toString());
       26 │ + for·(const·x·in/*comment*/·Object.hasOwn(object,·property).toString());
    27 27 │   function foo(){return({}.hasOwnProperty.call)(object, property)}
    28 28 │   Object['prototype']['hasOwnProperty']['call'](object, property);
  

```

```
invalid.js:27:22 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
    25 │ for (const x in{}.hasOwnProperty.call(object, property).toString());
    26 │ for (const x in/*comment*/{}.hasOwnProperty.call(object, property).toString());
  > 27 │ function foo(){return({}.hasOwnProperty.call)(object, property)}
       │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    28 │ Object['prototype']['hasOwnProperty']['call'](object, property);
    29 │ Object[`prototype`][`hasOwnProperty`][`call`](object, property);
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    25 25 │   for (const x in{}.hasOwnProperty.call(object, property).toString());
    26 26 │   for (const x in/*comment*/{}.hasOwnProperty.call(object, property).toString());
    27    │ - function·foo(){return({}.hasOwnProperty.call)(object,·property)}
       27 │ + function·foo(){return(Object.hasOwn)(object,·property)}
    28 28 │   Object['prototype']['hasOwnProperty']['call'](object, property);
    29 29 │   Object[`prototype`][`hasOwnProperty`][`call`](object, property);
  

```

```
invalid.js:28:1 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
    26 │ for (const x in/*comment*/{}.hasOwnProperty.call(object, property).toString());
    27 │ function foo(){return({}.hasOwnProperty.call)(object, property)}
  > 28 │ Object['prototype']['hasOwnProperty']['call'](object, property);
       │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    29 │ Object[`prototype`][`hasOwnProperty`][`call`](object, property);
    30 │ Object['hasOwnProperty']['call'](object, property);
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    26 26 │   for (const x in/*comment*/{}.hasOwnProperty.call(object, property).toString());
    27 27 │   function foo(){return({}.hasOwnProperty.call)(object, property)}
    28    │ - Object['prototype']['hasOwnProperty']['call'](object,·property);
       28 │ + Object.hasOwn(object,·property);
    29 29 │   Object[`prototype`][`hasOwnProperty`][`call`](object, property);
    30 30 │   Object['hasOwnProperty']['call'](object, property);
  

```

```
invalid.js:29:1 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
    27 │ function foo(){return({}.hasOwnProperty.call)(object, property)}
    28 │ Object['prototype']['hasOwnProperty']['call'](object, property);
  > 29 │ Object[`prototype`][`hasOwnProperty`][`call`](object, property);
       │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    30 │ Object['hasOwnProperty']['call'](object, property);
    31 │ Object[`hasOwnProperty`][`call`](object, property);
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    27 27 │   function foo(){return({}.hasOwnProperty.call)(object, property)}
    28 28 │   Object['prototype']['hasOwnProperty']['call'](object, property);
    29    │ - Object[`prototype`][`hasOwnProperty`][`call`](object,·property);
       29 │ + Object.hasOwn(object,·property);
    30 30 │   Object['hasOwnProperty']['call'](object, property);
    31 31 │   Object[`hasOwnProperty`][`call`](object, property);
  

```

```
invalid.js:30:1 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
    28 │ Object['prototype']['hasOwnProperty']['call'](object, property);
    29 │ Object[`prototype`][`hasOwnProperty`][`call`](object, property);
  > 30 │ Object['hasOwnProperty']['call'](object, property);
       │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    31 │ Object[`hasOwnProperty`][`call`](object, property);
    32 │ ({})['hasOwnProperty']['call'](object, property);
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    28 28 │   Object['prototype']['hasOwnProperty']['call'](object, property);
    29 29 │   Object[`prototype`][`hasOwnProperty`][`call`](object, property);
    30    │ - Object['hasOwnProperty']['call'](object,·property);
       30 │ + Object.hasOwn(object,·property);
    31 31 │   Object[`hasOwnProperty`][`call`](object, property);
    32 32 │   ({})['hasOwnProperty']['call'](object, property);
  

```

```
invalid.js:31:1 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
    29 │ Object[`prototype`][`hasOwnProperty`][`call`](object, property);
    30 │ Object['hasOwnProperty']['call'](object, property);
  > 31 │ Object[`hasOwnProperty`][`call`](object, property);
       │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    32 │ ({})['hasOwnProperty']['call'](object, property);
    33 │ ({})[`hasOwnProperty`][`call`](object, property);
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    29 29 │   Object[`prototype`][`hasOwnProperty`][`call`](object, property);
    30 30 │   Object['hasOwnProperty']['call'](object, property);
    31    │ - Object[`hasOwnProperty`][`call`](object,·property);
       31 │ + Object.hasOwn(object,·property);
    32 32 │   ({})['hasOwnProperty']['call'](object, property);
    33 33 │   ({})[`hasOwnProperty`][`call`](object, property);
  

```

```
invalid.js:32:1 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
    30 │ Object['hasOwnProperty']['call'](object, property);
    31 │ Object[`hasOwnProperty`][`call`](object, property);
  > 32 │ ({})['hasOwnProperty']['call'](object, property);
       │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    33 │ ({})[`hasOwnProperty`][`call`](object, property);
    34 │ 
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    30 30 │   Object['hasOwnProperty']['call'](object, property);
    31 31 │   Object[`hasOwnProperty`][`call`](object, property);
    32    │ - ({})['hasOwnProperty']['call'](object,·property);
       32 │ + Object.hasOwn(object,·property);
    33 33 │   ({})[`hasOwnProperty`][`call`](object, property);
    34 34 │   
  

```

```
invalid.js:33:1 lint/nursery/useObjectHasOwn  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ! Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'.
  
    31 │ Object[`hasOwnProperty`][`call`](object, property);
    32 │ ({})['hasOwnProperty']['call'](object, property);
  > 33 │ ({})[`hasOwnProperty`][`call`](object, property);
       │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    34 │ 
  
  i Safe fix: Use 'Object.hasOwn()' instead.
  
    31 31 │   Object[`hasOwnProperty`][`call`](object, property);
    32 32 │   ({})['hasOwnProperty']['call'](object, property);
    33    │ - ({})[`hasOwnProperty`][`call`](object,·property);
       33 │ + Object.hasOwn(object,·property);
    34 34 │   
  

```

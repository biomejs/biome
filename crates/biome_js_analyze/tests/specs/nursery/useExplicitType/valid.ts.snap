---
source: crates/biome_js_analyze/tests/spec_tests.rs
expression: valid.ts
---
# Input
```ts
/* should not generate diagnostics */
function test(): void {
	return;
}

var fn = function (): number {
	return 1;
};

var arrowFn = (): string => "test";

class Test {
	constructor() {}
	get prop(): number {
		return 1;
	}
	set prop() {}
	method(): void {
		return;
	}
	arrow = (): string => "arrow";
}

var obj = {
	method(): string {
		return "test";
	},
};

var obj = {
	get method(): string {
		return "test";
	},
	set method(val: string) {
		console.log(val);
	},
};

export default (): void => {};
export default function (): void {}

// check direct var assertions
var func = (value: number) => ({ foo: "bar", value }) as const;
var func = () => x as const;

// check allow expressions
node.addEventListener("click", () => {});
node.addEventListener("click", function () {});
fn(() => {});
fn(function () {});
new Promise(() => {});
new Foo(1, () => {});
(function () {
	console.log("This is an IIFE");
})();
(() => {
	console.log("This is an IIFE");
})();
setTimeout(function () {
	console.log("Hello!");
}, 1000);

// check higher order functions
var arrowFn = () => (): void => {};
var arrowFn = () => function (): void {};
var arrowFn = () => {
	return (): void => {};
};

// type assertion
var asTyped = (() => "") as () => string;
var castTyped = <() => string>(() => "");

// variable declarator with a type annotation
type FuncType = () => string;
var arrowFn: FuncType = () => "test";
var funcExpr: FuncType = function () {
	return "test";
};

// default parameter with a type annotation
type CallBack = () => void;
var f = (gotcha: CallBack = () => {}): void => {};
function f(gotcha: CallBack = () => {}): void {}

// class property with a type annotation
type MethodType = () => void;
class App {
	private method: MethodType = () => {};
}

// function as a property or a nested property of a typed object
var x: Foo = { prop: () => {} };
var x = { prop: () => {} } as Foo;
var x = <Foo>{ prop: () => {} };

var x: Foo = { bar: { prop: () => {} } };

class Accumulator {
	private count: number = 0;
	public accumulate(fn: () => number): void {
		this.count += fn();
	}
}
new Accumulator().accumulate(() => 1);

// Returning object from function
interface Behavior {
  namedFunc: () => string;
  arrowFunc: () => string;
}

function getObjectWithFunction(): Behavior {
  return {
    namedFunc: function myFunc(): string { return "value" },
    arrowFunc: () => {},
  }
}

var getObjectWithFunction1 = (): Behavior => {
	return {
		namedFunc: function myFunc(): string { return "value" },
		arrowFunc: () => {},
	}
}


interface Array<Type> {
	pop(): Type | undefined;
	push(...items: Type[]): number;
}

type MyObject = {
	(input: string): string;
	propertyName: string;
};

abstract class MyClass {
	public abstract method(): string;
}

abstract class P<T> {
	abstract method(): T;
	abstract get poke(): string;
}

declare namespace myLib {
	function makeGreeting(s: string): string;
}

declare module "foo" {
	export default function bar(): string;
}

var X: Type = { prop: () => {} };
f({ prop: () => {} })

var foo: unknown[] = arr.map((i) => i * i);
new Promise((resolve) => resolve(1));
new Promise(resolve => resolve(1));

const x: string | null = someFunc();
let x: string | null;
var x: string | null;

const x = "";
const x = 1;
const x = null;
const x = undefined;

let x = "";
let x = 1;

var x = "";
var x = 1;

const fn = (x: number): void => {};

var obj = {
	x: 1,
	func: (x: number): void => {},
	meth(x: number): string {},
}
let obj = {
	x: 1,
	func: (x: number): void => {},
	meth(x: number): string {},
}
const obj = {
	x: 1,
	func: (x: number): void => {},
	meth(x: number): string {},
}

const obj = { dynamic: someFunc() as string }
const obj = { dynamic: <string>(someFunc()) }

namespace Ns {
	export const X = {};
	export function func(arg: string): void {}
}

// Binary expressions with trivially inferrable operands
const two = 1 + 1;
const sum = 5 + 10;
const product = 2 * 3;
const difference = 10 - 5;
const quotient = 20 / 4;
const remainder = 10 % 3;
const power = 2 ** 3;
const stringConcat = "hello" + "world";
const booleanAnd = true && false;
const booleanOr = true || false;
const comparison = 5 > 3;
const complexMath = 1 + 2 * 3 - 4 / 2;

// Comparison expressions (always return boolean)
const stringComparison = 'test' === 'test';
const numberComparison = 42 !== 0;
const strictEquality = 1 === 1;
const strictInequality = 2 !== 3;
const equality = 'a' == 'a';
const inequality = 'b' != 'c';
const greaterThan = 10 > 5;
const lessThan = 3 < 7;
const greaterOrEqual = 5 >= 5;
const lessOrEqual = 4 <= 10;

// Class instantiation (new expressions)
class Vehicle {}
const myVehicle = new Vehicle();

class Product {
	constructor(public value: number) {}
}
const myProduct = new Product(42);

const myDate = new Date();
const myMap = new Map();
const mySet = new Set();
const myError = new Error("message");
const myPromise = new Promise((resolve) => resolve(1));
const myArray = new Array(10);
const myRegex = new RegExp("pattern");

// Array expressions with trivially inferrable elements
const numbers = [1, 2, 3, 4, 5];
const strings = ['a', 'b', 'c'];
const booleans = [true, false, true];
const mixed = [1, 'text', true];
const nested = [[1, 2], [3, 4]];
const empty = [];
const withHoles = [1, , 3];

// Conditional expressions with trivially inferrable branches
const string = true ? 'yes' : 'no';
const number = false ? 1 : 0;
const conditional = 5 > 3 ? 'greater' : 'less';
const nestedConditional = true ? (false ? 'a' : 'b') : 'c';
const mixedConditional = true ? 1 : 'string';

// Call expressions (function/method calls) with inferrable return types
const randomNumber = Math.random();
const upper = "hello".toUpperCase();
const trimmed = "  test  ".trim();
const mapped = [1, 2, 3].map(x => x * 2);
const keys = Object.keys({a: 1, b: 2});
const values = Object.values({a: 1, b: 2});
const now = new Date().getTime();

// Function parameters with trivially inferrable default values
const greetings = (word = 'hello'): string => { return `${word} world`; };
const add = (a = 0, b = 0): number => a + b;
const multiply = (x = 1, y = 1): number => x * y;
const isActive = (active = true): boolean => active;
const getUser = (name = 'Guest', age = 18): string => `${name} is ${age}`;
function processValue(value = 42): number { return value * 2; }
function greet(message = 'Hello'): void { console.log(message); }
const calculate = (num = 100): number => num + 10;


```

_Note: The parser emitted 2 diagnostics which are not shown here._

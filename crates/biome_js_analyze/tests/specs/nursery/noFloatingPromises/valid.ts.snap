---
source: crates/biome_js_analyze/tests/spec_tests.rs
expression: valid.ts
---
# Input
```ts
/* should not generate diagnostics */
async function returnsPromise(): Promise<string> {
  return 'value';
}

await returnsPromise();
void returnsPromise();
return returnsPromise();

returnsPromise().then(
  () => { },
  () => { },
);

returnsPromise().catch(() => { });


const promise = new Promise((resolve) => resolve('value'));
promise.then(() => { }, () => { })

Promise.resolve('value').then(() => { }, () => { })
Promise.all([p1, p2, p3]).catch(() => { })

const Promise = { resolve(): {} };
Promise.resolve()
async function bindingPromiseInsideFunction() {
  Promise.resolve()
}


class ValidTestClass {
  returnsPromiseProperty: Promise<void>
  constructor() {
    this.returnsPromiseProperty = new Promise((resolve, reject) => { })
  }

  async returnsPromiseMethod(): Promise<string> {
    return 'value';
  }
  async someMethod() {
    this.returnsPromiseMethod().catch(() => { });
  }

  returnsString(): string {
    return 'value';
  }
  async someMethod2() {
    this.returnsString();
  }

  async someMethod3() {
    this.returnsPromiseProperty.then(() => { }, () => { });
  }

  returnsPromiseFunction = async function (): Promise<string> {
    return 'value';
  }
  returnsPromiseArrowFunction = async (): Promise<string> => {
    return 'value';
  }

  async someMetho3() {
    await this.returnsPromiseFunction().then(() => { });
    this.returnsPromiseArrowFunction().catch(() => { });
  }
}
```

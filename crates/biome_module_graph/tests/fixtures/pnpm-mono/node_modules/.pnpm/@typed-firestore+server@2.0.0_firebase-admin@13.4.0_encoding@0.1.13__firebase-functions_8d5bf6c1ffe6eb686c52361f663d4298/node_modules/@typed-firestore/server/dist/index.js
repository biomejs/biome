import {
  getBeforeAndAfterOnUpdated,
  getBeforeAndAfterOnWritten,
  getDataOnCreated,
  getDataOnWritten,
  getErrorMessage,
  invariant,
  isDefined,
  isJsonObject,
  verboseCount,
  verboseLog
} from "./chunk-W2Y3DCZ3.js";

// src/documents/add-document.ts
import "firebase-admin/firestore";
async function addDocument(ref, data) {
  const docRef = await ref.add(data);
  return docRef.id;
}

// src/documents/delete-document.ts
import "firebase-admin/firestore";
async function deleteDocument(ref, documentId) {
  await ref.doc(documentId).delete();
}

// src/documents/make-mutable-document.ts
function makeMutableDocument(doc) {
  return {
    id: doc.id,
    data: doc.data(),
    ref: doc.ref,
    update: (data) => doc.ref.update(data),
    updateWithPartial: (data) => doc.ref.update(data),
    delete: () => doc.ref.delete()
  };
}
function makeMutableDocumentTx(tx, doc) {
  return {
    id: doc.id,
    data: doc.data(),
    ref: doc.ref,
    update: (data) => tx.update(doc.ref, data),
    updateWithPartial: (data) => tx.update(doc.ref, data),
    delete: () => tx.delete(doc.ref)
  };
}

// src/documents/get-document.ts
async function getDocument(ref, documentId) {
  const doc = await ref.doc(documentId).get();
  invariant(doc.exists, `No document available at ${ref.path}/${documentId}`);
  return makeMutableDocument(doc);
}
async function getDocumentMaybe(ref, documentId) {
  if (!documentId) return;
  const doc = await ref.doc(documentId).get();
  if (!doc.exists) return;
  return makeMutableDocument(doc);
}
async function getDocumentTx(tx, ref, documentId) {
  const doc = await tx.get(ref.doc(documentId));
  invariant(doc.exists, `No document available at ${ref.path}/${documentId}`);
  return makeMutableDocumentTx(tx, doc);
}
async function getDocumentMaybeTx(tx, ref, documentId) {
  if (!documentId) return;
  const doc = await tx.get(ref.doc(documentId));
  if (!doc.exists) {
    return;
  }
  return makeMutableDocumentTx(tx, doc);
}

// src/documents/get-document-data.ts
async function getDocumentData(ref, documentId) {
  const doc = await ref.doc(documentId).get();
  invariant(doc.exists, `No document available at ${ref.path}/${documentId}`);
  return doc.data();
}
async function getDocumentDataMaybe(ref, documentId) {
  if (!documentId) return;
  const doc = await ref.doc(documentId).get();
  if (!doc.exists) return;
  return doc.data();
}
async function getDocumentDataTx(tx, ref, documentId) {
  const doc = await tx.get(ref.doc(documentId));
  invariant(doc.exists, `No document available at ${ref.path}/${documentId}`);
  return doc.data();
}
async function getDocumentDataMaybeTx(tx, ref, documentId) {
  if (!documentId) return;
  const doc = await tx.get(ref.doc(documentId));
  if (!doc.exists) {
    return;
  }
  return doc.data();
}

// src/documents/get-specific-document.ts
async function getSpecificDocument(ref) {
  const doc = await ref.get();
  invariant(doc.exists, `No document available at ${ref.path}`);
  return makeMutableDocument(doc);
}
async function getSpecificDocumentMaybe(ref) {
  const doc = await ref.get();
  if (!doc.exists) return;
  return makeMutableDocument(doc);
}
async function getSpecificDocumentTx(tx, ref) {
  const doc = await tx.get(ref);
  invariant(doc.exists, `No document available at ${ref.path}`);
  return makeMutableDocumentTx(tx, doc);
}
async function getSpecificDocumentMaybeTx(tx, ref) {
  const doc = await tx.get(ref);
  if (!doc.exists) return;
  return makeMutableDocumentTx(tx, doc);
}

// src/documents/get-specific-document-data.ts
async function getSpecificDocumentData(ref) {
  const doc = await getSpecificDocument(ref);
  return doc.data;
}
async function getSpecificDocumentDataMaybe(ref) {
  const doc = await getSpecificDocumentMaybe(ref);
  return doc?.data;
}
async function getSpecificDocumentDataMaybeTx(tx, ref) {
  const doc = await tx.get(ref);
  if (!doc.exists) return;
  return makeMutableDocumentTx(tx, doc);
}

// src/documents/make-document.ts
function makeDocument(doc) {
  return {
    id: doc.id,
    data: doc.data()
  };
}

// src/documents/make-document-human-readable.ts
import { Timestamp } from "firebase-admin/firestore";
function makeDocumentHumanReadable(documentData) {
  return sortObjectKeysRecursive(convertTimestampsRecursive(documentData));
}
function convertTimestampsRecursive(data) {
  const convertedData = { ...data };
  for (const [key, value] of Object.entries(convertedData)) {
    if (value instanceof Timestamp) {
      convertedData[key] = `(timestamp) ${value.toDate().toISOString()}`;
    } else if (isJsonObject(value)) {
      convertedData[key] = convertTimestampsRecursive(value);
    }
  }
  return convertedData;
}
function sortObjectKeys(obj) {
  return Object.fromEntries(
    Object.entries(obj).sort(([keyA], [keyB]) => keyA.localeCompare(keyB))
  );
}
function sortObjectKeysRecursive(obj) {
  const sortedObj = sortObjectKeys(obj);
  for (const [key, value] of Object.entries(sortedObj)) {
    if (isJsonObject(value)) {
      sortedObj[key] = sortObjectKeysRecursive(value);
    } else if (Array.isArray(value)) {
      sortedObj[key] = value.map(
        (item) => isJsonObject(item) ? sortObjectKeysRecursive(item) : item
      );
    }
  }
  return sortedObj;
}

// src/documents/set-document.ts
import "firebase-admin/firestore";
async function setDocument(ref, documentId, data, options = {}) {
  await ref.doc(documentId).set(data, options);
}
function setDocumentTx(tx, ref, documentId, data, options = {}) {
  tx.set(ref.doc(documentId), data, options);
}

// src/documents/set-specific-document.ts
async function setSpecificDocument(ref, data, options = {}) {
  await ref.set(data, options);
}
function setSpecificDocumentTx(tx, ref, data, options = {}) {
  tx.set(ref, data, options);
}

// src/documents/update-document.ts
import "firebase-admin/firestore";
async function updateDocument(ref, documentId, data) {
  await ref.doc(documentId).update(data);
}
async function updateDocumentWithPartial(ref, documentId, data) {
  await ref.doc(documentId).update(data);
}
function updateDocumentTx(tx, ref, documentId, data) {
  tx.update(ref.doc(documentId), data);
}
function updateDocumentPartialTx(tx, ref, documentId, data) {
  tx.update(ref.doc(documentId), data);
}

// src/documents/update-specific-document.ts
import "firebase-admin/firestore";
async function updateSpecificDocument(ref, data) {
  await ref.update(data);
}
async function updateSpecificDocumentWithPartial(ref, data) {
  await ref.update(data);
}
function updateSpecificDocumentTx(tx, ref, data) {
  tx.update(ref, data);
}
function updateSpecificDocumentPartialTx(tx, ref, data) {
  tx.update(ref, data);
}

// src/collections/constants.ts
var DEFAULT_CHUNK_SIZE = 500;
var MAX_QUERY_LIMIT = 1e3;

// src/collections/helpers/get-query-info.ts
function getQueryInfo(query) {
  const internalQuery = query;
  const queryOptions = internalQuery._queryOptions;
  if (!queryOptions) return {};
  return {
    limit: typeof queryOptions.limit === "number" ? queryOptions.limit : void 0,
    select: queryOptions.projection?.fields?.map((field) => field.fieldPath)
  };
}

// src/collections/helpers/build-query.ts
function buildQuery(ref, queryFn, optionsSelect) {
  const queryInfo = queryFn ? getQueryInfo(queryFn(ref)) : {};
  const { limit, select: querySelect } = queryInfo;
  invariant(
    !limit || limit <= MAX_QUERY_LIMIT,
    `Limit ${String(limit)} is greater than the maximum query limit of ${String(MAX_QUERY_LIMIT)}`
  );
  invariant(
    !querySelect,
    "Select is not allowed to be set on the query. Use the options instead."
  );
  const disableChunking = isDefined(limit);
  const baseQuery = queryFn ? queryFn(ref) : ref;
  const query = optionsSelect ? baseQuery.select(...optionsSelect) : baseQuery;
  return { query, disableChunking, limit };
}

// src/collections/helpers/get-chunk-of-documents.ts
async function getChunkOfDocuments(query, startAfterSnapshot, batchSize) {
  const limitedQuery = query.limit(batchSize);
  const pagedQuery = startAfterSnapshot ? limitedQuery.startAfter(startAfterSnapshot) : limitedQuery;
  const snapshot = await pagedQuery.get();
  if (snapshot.empty) {
    return [[], void 0];
  }
  const documents = snapshot.docs.map(
    (doc) => makeMutableDocument(doc)
  );
  const lastSnapshot = documents.length < batchSize ? void 0 : snapshot.docs.at(-1);
  return [documents, lastSnapshot];
}

// src/collections/helpers/get-all-documents-chunked.ts
async function getDocumentsChunked(query, chunkSize = DEFAULT_CHUNK_SIZE) {
  const documents = [];
  let startAfterSnapshot;
  do {
    verboseCount("Fetching chunk");
    const [chunk, lastSnapshot] = await getChunkOfDocuments(
      query,
      startAfterSnapshot,
      chunkSize
    );
    documents.push(...chunk);
    startAfterSnapshot = lastSnapshot;
  } while (startAfterSnapshot);
  return documents;
}

// src/collections/get-documents.ts
async function getDocuments(ref, queryFn, options = {}) {
  const { query, disableChunking, limit } = buildQuery(
    ref,
    queryFn,
    options.select
  );
  if (disableChunking) {
    invariant(
      limit && limit <= MAX_QUERY_LIMIT,
      `Limit ${String(limit)} is greater than the maximum query limit of ${String(MAX_QUERY_LIMIT)}`
    );
    const snapshot = await query.get();
    return snapshot.docs.map(
      (doc) => makeMutableDocument(
        doc
      )
    );
  } else {
    return getDocumentsChunked(
      query,
      options.chunkSize
    );
  }
}
async function getDocumentsData(ref, queryFn, options = {}) {
  const documents = await getDocuments(ref, queryFn, options);
  return documents.map((doc) => doc.data);
}
async function getDocumentsTx(tx, ref, queryFn, options = {}) {
  const { query } = buildQuery(ref, queryFn, options.select);
  const snapshot = await tx.get(query);
  if (snapshot.empty) return [];
  return snapshot.docs.map(
    (doc) => makeMutableDocumentTx(
      tx,
      doc
    )
  );
}
async function getDocumentsDataTx(tx, ref, queryFn, options = {}) {
  const documents = await getDocumentsTx(tx, ref, queryFn, options);
  return documents.map((doc) => doc.data);
}

// src/collections/get-first-document.ts
async function getFirstDocument(ref, queryFn, options = {}) {
  const queryInfo = getQueryInfo(queryFn(ref));
  const { limit, select: querySelect } = queryInfo;
  invariant(
    !isDefined(limit),
    `You should not set a limit when calling getFirstDocument. It returns only one document.`
  );
  invariant(
    !querySelect,
    "Select is not allowed to be set on the query. Use the options instead."
  );
  const query = options.select ? queryFn(ref).select(...options.select) : queryFn(ref);
  const snapshot = await query.limit(1).get();
  if (snapshot.empty) {
    return;
  }
  return makeMutableDocument(
    snapshot.docs[0]
  );
}
async function getFirstDocumentData(ref, queryFn, options = {}) {
  const document = await getFirstDocument(ref, queryFn, options);
  return document?.data;
}
async function getFirstDocumentTx(tx, ref, queryFn, options = {}) {
  const queryInfo = getQueryInfo(queryFn(ref));
  const { limit, select: querySelect } = queryInfo;
  invariant(
    !isDefined(limit),
    `You should not set a limit when calling getFirstDocument. It returns only one document.`
  );
  invariant(
    !querySelect,
    "Select is not allowed to be set on the query. Use the options instead."
  );
  const query = options.select ? queryFn(ref).select(...options.select) : queryFn(ref);
  const snapshot = await tx.get(query.limit(1));
  if (snapshot.empty) {
    return;
  }
  return makeMutableDocumentTx(
    tx,
    snapshot.docs[0]
  );
}
async function getFirstDocumentDataTx(tx, ref, queryFn, options = {}) {
  const document = await getFirstDocumentTx(tx, ref, queryFn, options);
  return document?.data;
}

// src/collections/process-documents.ts
import { processInChunks, processInChunksByChunk } from "process-in-chunks";
var MAX_STORED_ERRORS = 1e3;
function handleProcessingError(id, err) {
  const message = getErrorMessage(err);
  console.error(`Error processing document ${id}: ${message}`);
}
async function processDocuments(ref, queryFn, handler, options = {}) {
  const { query, disableChunking, limit } = buildQuery(
    ref,
    queryFn,
    options.select
  );
  const { throttleSeconds = 0, chunkSize = DEFAULT_CHUNK_SIZE } = options;
  let errorCount = 0;
  if (disableChunking) {
    invariant(
      limit && limit <= MAX_QUERY_LIMIT,
      `Limit ${String(limit)} is greater than the maximum query limit of ${String(MAX_QUERY_LIMIT)}`
    );
    const documents = await getDocuments(ref, queryFn, options);
    await processInChunks(
      documents,
      async (doc) => {
        try {
          await handler(doc);
        } catch (err) {
          if (errorCount < MAX_STORED_ERRORS) {
            handleProcessingError(doc.id, err);
            errorCount++;
          }
        }
      },
      { throttleSeconds, chunkSize }
    );
  } else {
    let lastDocumentSnapshot;
    let count = 0;
    do {
      verboseCount("Processing chunk");
      const [documents, _lastDocumentSnapshot] = await getChunkOfDocuments(query, lastDocumentSnapshot, chunkSize);
      await processInChunks(
        documents,
        async (doc) => {
          try {
            await handler(doc);
          } catch (err) {
            if (errorCount < MAX_STORED_ERRORS) {
              handleProcessingError(doc.id, err);
              errorCount++;
            }
          }
        },
        { throttleSeconds, chunkSize }
      );
      count += documents.length;
      lastDocumentSnapshot = _lastDocumentSnapshot;
    } while (isDefined(lastDocumentSnapshot));
    verboseLog(`Processed ${String(count)} documents`);
  }
  if (errorCount >= MAX_STORED_ERRORS) {
    console.warn(
      `Error logging was limited to ${String(MAX_STORED_ERRORS)} errors`
    );
  }
}
async function processDocumentsByChunk(ref, queryFn, handler, options = {}) {
  const { query, disableChunking } = buildQuery(ref, queryFn, options.select);
  const { throttleSeconds = 0, chunkSize = DEFAULT_CHUNK_SIZE } = options;
  const errors = [];
  if (disableChunking) {
    const documents = await getDocuments(ref, queryFn, options);
    try {
      await processInChunksByChunk(
        documents,
        async (docs) => {
          await handler(docs);
        },
        { throttleSeconds, chunkSize }
      );
    } catch (err) {
      errors.push(getErrorMessage(err));
    }
  } else {
    let lastDocumentSnapshot;
    let count = 0;
    do {
      verboseCount("Processing chunk");
      const [documents, _lastDocumentSnapshot] = await getChunkOfDocuments(query, lastDocumentSnapshot, chunkSize);
      try {
        await processInChunksByChunk(
          documents,
          async (docs) => {
            await handler(docs);
          },
          { throttleSeconds, chunkSize }
        );
      } catch (err) {
        errors.push(getErrorMessage(err));
      }
      count += documents.length;
      lastDocumentSnapshot = _lastDocumentSnapshot;
    } while (isDefined(lastDocumentSnapshot));
    verboseLog(`Processed ${String(count)} documents`);
    if (errors.length > 0) {
      errors.forEach((message) => {
        console.error(message);
      });
    }
  }
}
export {
  addDocument,
  deleteDocument,
  getBeforeAndAfterOnUpdated,
  getBeforeAndAfterOnWritten,
  getDataOnCreated,
  getDataOnWritten,
  getDocument,
  getDocumentData,
  getDocumentDataMaybe,
  getDocumentDataMaybeTx,
  getDocumentDataTx,
  getDocumentMaybe,
  getDocumentMaybeTx,
  getDocumentTx,
  getDocuments,
  getDocumentsData,
  getDocumentsDataTx,
  getDocumentsTx,
  getFirstDocument,
  getFirstDocumentData,
  getFirstDocumentDataTx,
  getFirstDocumentTx,
  getSpecificDocument,
  getSpecificDocumentData,
  getSpecificDocumentDataMaybe,
  getSpecificDocumentDataMaybeTx,
  getSpecificDocumentMaybe,
  getSpecificDocumentMaybeTx,
  getSpecificDocumentTx,
  makeDocument,
  makeDocumentHumanReadable,
  makeMutableDocument,
  makeMutableDocumentTx,
  processDocuments,
  processDocumentsByChunk,
  setDocument,
  setDocumentTx,
  setSpecificDocument,
  setSpecificDocumentTx,
  updateDocument,
  updateDocumentPartialTx,
  updateDocumentTx,
  updateDocumentWithPartial,
  updateSpecificDocument,
  updateSpecificDocumentPartialTx,
  updateSpecificDocumentTx,
  updateSpecificDocumentWithPartial
};
//# sourceMappingURL=index.js.map
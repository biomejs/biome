use anyhow::{Context, Ok, Result};
use biome_string_case::Case;
use proc_macro2::TokenStream;
use quote::{format_ident, quote};
use std::{collections::BTreeMap, path::Path};
use xtask_glue::{glue::fs2, project_root, reformat};

/// Generate a build.rs file for an analyzer crate
fn generate_build_script(categories_and_groups: &BTreeMap<&str, Vec<String>>) -> Result<String> {
    let mut watch_calls = Vec::new();

    for (category, groups) in categories_and_groups {
        if groups.is_empty() {
            continue;
        }
        let mut groups = groups.clone();
        groups.sort();

        for group in groups {
            watch_calls.push(quote! {
                watch_group(#category, #group)?;
            });
        }
    }

    let tokens = quote! {
        //! Build script for #crate_name.
        //!
        //! THIS FILE IS AUTO-GENERATED by `just gen-analyzer`.
        //! DO NOT EDIT MANUALLY!
        //!
        //! This build script watches for changes to rule files in group directories
        //! and "touches" the corresponding group files to trigger recompilation.

        use std::env;
        use std::fs;
        use std::io;
        use std::path::PathBuf;
        use std::time::SystemTime;

        fn main() -> io::Result<()> {
            #( #watch_calls )*

            Ok(())
        }

        /// Watch a specific group directory and touch its group file when changes occur
        fn watch_group(category: &str, group: &str) -> io::Result<()> {
            let manifest_dir = env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR not set");
            let base_path = PathBuf::from(&manifest_dir).join("src");

            let group_dir = base_path.join(category).join(group);
            let group_file = base_path.join(category).join(format!("{}.rs", group));

            // Tell cargo to rerun if the group directory itself changes
            println!("cargo:rerun-if-changed={}", group_dir.display());

            // Watch all .rs files in the group directory
            if let Ok(entries) = fs::read_dir(&group_dir) {
                for entry in entries.flatten() {
                    let path = entry.path();
                    if path.extension().is_some_and(|ext| ext == "rs") {
                        println!("cargo:rerun-if-changed={}", path.display());
                    }
                }
            }

            // Touch the group file to trigger proc macro rerun
            touch_file(&group_file)?;

            Ok(())
        }

        /// Update the modification time of a file to trigger recompilation
        fn touch_file(path: &PathBuf) -> io::Result<()> {
            if !path.exists() {
                return Ok(());
            }

            let now = filetime::FileTime::from_system_time(SystemTime::now());
            filetime::set_file_mtime(path, now)?;

            Ok(())
        }
    };

    reformat(tokens)
}

/// Generate an analyzer crate's category files, build script, and registry.
fn generate_analyzer_crate(
    crate_name: &str,
    categories: &[&'static str],
    update_registry: fn(BTreeMap<&'static str, TokenStream>) -> Result<()>,
) -> Result<()> {
    let base_path = project_root().join(format!("crates/{crate_name}/src"));
    let mut analyzers = BTreeMap::new();
    let mut categories_and_groups = BTreeMap::new();

    for &category in categories {
        if base_path.join(category).exists() {
            let groups = generate_category(category, &mut analyzers, &base_path)?;
            if !groups.is_empty() {
                categories_and_groups.insert(category, groups);
            }
        }
    }

    let build_script = generate_build_script(&categories_and_groups)?;
    let build_rs_path = project_root().join(format!("crates/{crate_name}/build.rs"));
    fs2::write(build_rs_path, build_script)?;

    update_registry(analyzers)
}

pub fn generate_analyzer() -> Result<()> {
    generate_analyzer_crate(
        "biome_js_analyze",
        &["lint", "assist", "syntax"],
        update_js_registry_builder,
    )?;
    generate_analyzer_crate(
        "biome_json_analyze",
        &["lint", "assist"],
        update_json_registry_builder,
    )?;
    generate_analyzer_crate(
        "biome_css_analyze",
        &["lint", "assist"],
        update_css_registry_builder,
    )?;
    generate_analyzer_crate(
        "biome_graphql_analyze",
        &["lint"],
        update_graphql_registry_builder,
    )?;
    generate_analyzer_crate(
        "biome_html_analyze",
        &["lint", "assist"],
        update_html_registry_builder,
    )?;
    Ok(())
}

fn generate_category(
    name: &'static str,
    entries: &mut BTreeMap<&'static str, TokenStream>,
    base_path: &Path,
) -> Result<Vec<String>> {
    let path = base_path.join(name);

    let mut groups = BTreeMap::new();
    let mut group_names = Vec::new();

    for entry in fs2::read_dir(path)? {
        let entry = entry?;
        if !entry.file_type()?.is_dir() {
            continue;
        }

        let entry = entry.path();
        let file_name = entry
            .file_stem()
            .context("path has no file name")?
            .to_str()
            .context("could not convert file name to string")?;

        generate_group(name, file_name, base_path)?;
        group_names.push(file_name.to_string());

        let module_name = format_ident!("{}", file_name);
        let group_name = format_ident!("{}", Case::Pascal.convert(file_name));

        groups.insert(
            file_name.to_string(),
            (
                quote! {
                   pub mod #module_name;
                },
                quote! {
                    self::#module_name::#group_name
                },
            ),
        );
    }

    let module_name = format_ident!("{name}");

    let category_name = Case::Pascal.convert(name);
    let category_name = format_ident!("{category_name}");

    let kind = match name {
        "syntax" => format_ident!("Syntax"),
        "lint" => format_ident!("Lint"),
        "assist" => format_ident!("Action"),
        _ => panic!("unimplemented analyzer category {name:?}"),
    };

    entries.insert(
        name,
        quote! {
            registry.record_category::<crate::#module_name::#category_name>();
        },
    );

    let (modules, paths): (Vec<_>, Vec<_>) = groups.into_values().unzip();
    let tokens = reformat(quote! {
        #( #modules )*
        ::biome_analyze::declare_category! {
            pub #category_name {
                kind: #kind,
                groups: [
                    #( #paths, )*
                ]
            }
        }
    })?;

    fs2::write(base_path.join(format!("{name}.rs")), tokens)?;

    Ok(group_names)
}

fn generate_group(category: &'static str, group: &str, base_path: &Path) -> Result<()> {
    // Generate simple proc macro invocation instead of full code
    let tokens = reformat(quote! {
        //! Group description generated by proc macro at compile time.
        //!
        //! To add a new rule, create a `.rs` file in the group subdirectory
        //! and run `cargo check`. The build system will automatically discover
        //! and register your rule.

        use biome_analyze_macros::declare_group_from_fs;

        declare_group_from_fs! {
            category: #category,
            group: #group
        }
    })?;

    fs2::write(base_path.join(category).join(format!("{group}.rs")), tokens)?;

    Ok(())
}

fn update_js_registry_builder(analyzers: BTreeMap<&'static str, TokenStream>) -> Result<()> {
    let path = project_root().join("crates/biome_js_analyze/src/registry.rs");

    let categories = analyzers.into_values();

    let tokens = reformat(quote! {
        use biome_analyze::RegistryVisitor;
        use biome_js_syntax::JsLanguage;

        pub fn visit_registry<V: RegistryVisitor<JsLanguage>>(registry: &mut V) {
            #( #categories )*
        }
    })?;

    fs2::write(path, tokens)?;

    Ok(())
}

fn update_json_registry_builder(analyzers: BTreeMap<&'static str, TokenStream>) -> Result<()> {
    let path = project_root().join("crates/biome_json_analyze/src/registry.rs");

    let categories = analyzers.into_values();

    let tokens = reformat(quote! {
        use biome_analyze::RegistryVisitor;
        use biome_json_syntax::JsonLanguage;

        pub fn visit_registry<V: RegistryVisitor<JsonLanguage>>(registry: &mut V) {
            #( #categories )*
        }
    })?;

    fs2::write(path, tokens)?;

    Ok(())
}

fn update_css_registry_builder(analyzers: BTreeMap<&'static str, TokenStream>) -> Result<()> {
    let path = project_root().join("crates/biome_css_analyze/src/registry.rs");

    let categories = analyzers.into_values();

    let tokens = reformat(quote! {
        use biome_analyze::RegistryVisitor;
        use biome_css_syntax::CssLanguage;

        pub fn visit_registry<V: RegistryVisitor<CssLanguage>>(registry: &mut V) {
            #( #categories )*
        }
    })?;

    fs2::write(path, tokens)?;

    Ok(())
}

fn update_graphql_registry_builder(analyzers: BTreeMap<&'static str, TokenStream>) -> Result<()> {
    let path = project_root().join("crates/biome_graphql_analyze/src/registry.rs");

    let categories = analyzers.into_values();

    let tokens = reformat(quote! {
        use biome_analyze::RegistryVisitor;
        use biome_graphql_syntax::GraphqlLanguage;

        pub fn visit_registry<V: RegistryVisitor<GraphqlLanguage>>(registry: &mut V) {
            #( #categories )*
        }
    })?;

    fs2::write(path, tokens)?;

    Ok(())
}

fn update_html_registry_builder(analyzers: BTreeMap<&'static str, TokenStream>) -> Result<()> {
    let path = project_root().join("crates/biome_html_analyze/src/registry.rs");

    let categories = analyzers.into_values();

    let tokens = reformat(quote! {
        use biome_analyze::RegistryVisitor;
        use biome_html_syntax::HtmlLanguage;

        pub fn visit_registry<V: RegistryVisitor<HtmlLanguage>>(registry: &mut V) {
            #( #categories )*
        }
    })?;

    fs2::write(path, tokens)?;

    Ok(())
}

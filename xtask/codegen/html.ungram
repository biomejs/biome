// HTML Un-Grammar.
//
// This grammar specifies the structure of Rust's concrete syntax tree.
// It does not specify parsing rules (ambiguities, precedence, etc are out of scope).
// Tokens are processed -- contextual keywords are recognised, compound operators glued.
//
// Legend:
//
//   //          				-- comment
//   Name =      				-- non-terminal definition
//   'ident'     				-- token (terminal)
//   A B         				-- sequence
//   A | B       				-- alternation
//   A*          				-- zero or more repetition
//   (A (',' A)* ','?)	-- repetition of node A separated by ',' and allowing a trailing comma
//   (A (',' A)*)	      -- repetition of node A separated by ',' without a trailing comma
//   A?          				-- zero or one repetition
//   (A)         				-- same as A
//   label:A     				-- suggested name for field of AST node

// NOTES
//
// - SyntaxNode, SyntaxToken and SyntaxElement will be stripped from the codegen
// - Bogus nodes are special nodes used to keep track of broken code; they are
//   not part of the grammar but they will appear inside the green tree


///////////////
// BOGUS NODES
///////////////
// SyntaxElement is a generic data structure that is meant to track nodes and tokens
// in cases where we care about both types
//
// As Bogus* node will need to yield both tokens and nodes without discrimination,
// and their children will need to yield nodes and tokens as well.
// For this reason, SyntaxElement = SyntaxElement
SyntaxElement = SyntaxElement

HtmlBogus = SyntaxElement*
HtmlBogusElement = SyntaxElement*
HtmlBogusAttribute = SyntaxElement*
AstroBogusFrontmatter = SyntaxElement*
HtmlBogusTextExpression = SyntaxElement*
SvelteBogusBlock = SyntaxElement*

HtmlRoot =
	bom: 'UNICODE_BOM'?
	frontmatter: AnyAstroFrontmatterElement?
	directive: HtmlDirective?
	html: HtmlElementList
	eof: 'EOF'

// <!DOCTYPE html>
// ^^^^^^^^^^^^^^^
HtmlDirective =
	'<'
	'!'
	doctype: 'doctype'
	html: 'html'?
	quirk: 'html_literal'?
	public_id: 'html_string_literal'?
	system_id: 'html_string_literal'?
	'>'

// ==================================
// Elements (AKA tags)
// ==================================

HtmlElementList = AnyHtmlElement*

AnyHtmlElement =
	HtmlSelfClosingElement
	| HtmlElement
	| AnyHtmlContent
	| HtmlCdataSection
	| HtmlBogusElement

AnyHtmlContent =
	HtmlContent
	| HtmlEmbeddedContent
	| AnyHtmlTextExpression
	| AnyGlimmerExpression

AnyHtmlTextExpression =
	HtmlDoubleTextExpression
	| HtmlSingleTextExpression
	| AnySvelteBlock
	| HtmlBogusTextExpression


// {{ expression }}
// ^^^^^^^^^^^^^^^^
HtmlDoubleTextExpression =
	'{{'
	expression: HtmlTextExpression
	'}}'

// {expression}
// ^^^^^^^^^^^^
HtmlSingleTextExpression =
	'{'
	expression: HtmlTextExpression
	'}'

HtmlTextExpression = 'html_literal'


// <a />
HtmlSelfClosingElement =
	'<'
	name: HtmlTagName
	attributes: HtmlAttributeList
	'/'?
	'>'

HtmlElement =
	opening_element: HtmlOpeningElement
	children: HtmlElementList
	closing_element: HtmlClosingElement


// <a href="">
// ^^        ^
HtmlOpeningElement =
	'<'
	name: HtmlTagName
	attributes: HtmlAttributeList
	'>'

// </a>
HtmlClosingElement =
	'<'
	'/'
	name: HtmlTagName
	'>'

// <![CDATA[example]]>
// Reference: https://html.spec.whatwg.org/multipage/syntax.html#cdata-sections
HtmlCdataSection =
	'<![CDATA['
	content: 'html_literal'
	']]>'

AnyAstroFrontmatterElement =
	AstroFrontmatterElement
	| AstroBogusFrontmatter

AstroFrontmatterElement =
	l_fence: '---'
	content: AstroEmbeddedContent
	r_fence: '---'

AstroEmbeddedContent =
	content: 'html_literal'?

// ==================================
// Attributes
// ==================================

HtmlAttributeList = AnyHtmlAttribute*

AnyHtmlAttribute =
	HtmlAttribute
	| HtmlDoubleTextExpression
	| HtmlSingleTextExpression
	| GlimmerSplattribute
	| HtmlBogusAttribute

// <a href="">
//    ^^^^^^^
HtmlAttribute =
	name: HtmlAttributeName
	initializer: HtmlAttributeInitializerClause?


// <a href="">
//        ^^^
HtmlAttributeInitializerClause =
	'='
	value: AnyHtmlAttributeInitializer


AnyHtmlAttributeInitializer =
	HtmlString
	| HtmlSingleTextExpression



// ==================================
// Svelte
// ==================================

AnySvelteBlock =
	SvelteDebugBlock
	| SvelteBogusBlock

// {@debug}
SvelteDebugBlock =
	'{@'
	'debug'
	bindings: SvelteBindingList
	'}'

SvelteBindingList = (SvelteName (',' SvelteName)*)

SvelteName = 'svelte_ident'

HtmlString = value: 'html_string_literal'
HtmlTagName = value: 'html_literal'
HtmlAttributeName = value: 'html_literal'
HtmlContent = value: 'html_literal'
HtmlEmbeddedContent = value: 'html_literal'

// ==================================
// Glimmer Template Syntax
// ==================================

GlimmerBogusExpression = SyntaxElement*

// Any Glimmer expression that can appear in content
AnyGlimmerExpression =
  GlimmerMustacheExpression
  | GlimmerBlockHelper
  | GlimmerBogusExpression

// Simple mustache expression: {{this.count}}, {{@arg}}, {{helper}}
GlimmerMustacheExpression =
'{{'
path: GlimmerPath
arguments: GlimmerArgumentList
'}}'

// Block helper: {{#if condition}}...{{/if}}, {{#each items as |item|}}...{{/each}}
GlimmerBlockHelper =
opening: GlimmerBlockHelperOpening
body: HtmlElementList
closing: GlimmerBlockHelperClosing

// Opening block helper: {{#if condition}} or {{#each items as |item|}}
GlimmerBlockHelperOpening =
'{{'
'#'
helper: GlimmerPath
arguments: GlimmerArgumentList
block_params: GlimmerBlockParams?
'}}'

// Closing block helper: {{/if}}, {{/each}}
GlimmerBlockHelperClosing =
'{{'
'/'
helper: GlimmerPath
'}}'

// Block parameters: as |item index|
GlimmerBlockParams =
'as'
'|'
params: GlimmerBlockParamList
'|'

GlimmerBlockParamList = (GlimmerBlockParam (',' GlimmerBlockParam)*)

GlimmerBlockParam = 'ident'

// Glimmer path: this.foo, @arg, or helper
GlimmerPath =
segments: GlimmerPathSegmentList

GlimmerPathSegmentList = GlimmerPathSegment*

GlimmerPathSegment =
'this'
| '@'
| 'ident'
| '.'

// Argument list for helpers: arg1 arg2 key=value
GlimmerArgumentList = AnyGlimmerArgument*

AnyGlimmerArgument =
  GlimmerPositionalArgument
  | GlimmerNamedArgument

// Positional argument: {{helper "string" 123 @arg}}
GlimmerPositionalArgument = value: AnyGlimmerArgumentValue

// Named argument: {{helper key=value}}
GlimmerNamedArgument =
name: 'ident'
'='
value: AnyGlimmerArgumentValue

AnyGlimmerArgumentValue =
  GlimmerPath
  | 'html_string_literal'
  | 'html_literal'

// Splattribute: ...attrs
GlimmerSplattribute =
'...'
name: 'ident'
